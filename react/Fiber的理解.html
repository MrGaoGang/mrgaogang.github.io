<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Fiber的理解 | 高小哥漫谈前端</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/icons/icon.png">
    <script src="/jquery/jquery.slim.min.js"></script>
    <script src="/readmore/index.js"></script>
    <link rel="stylesheet" type="text/css" href="/jquery/jquery.fancybox.min.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9cfd884fe46fc31072811d47a486a552";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9b661d4664669986af91448c055407cb";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script src="/jquery/jquery.fancybox.min.js"></script>
    <meta name="description" content="旨在分享对技术的了解">
    <meta name="google-site-verification" content="Wb79TZlc0Jau32a2Iph43MkdTZTvx75ZdHEOvRmxuoo">
    <meta name="baidu-site-verification" content="code-V304SBt3wm">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.14f02b24.css" as="style"><link rel="preload" href="/assets/js/app.818c8bb8.js" as="script"><link rel="preload" href="/assets/js/5.70973ade.js" as="script"><link rel="preload" href="/assets/js/3.ed5fe68d.js" as="script"><link rel="preload" href="/assets/js/196.0765e8f2.js" as="script"><link rel="prefetch" href="/assets/js/1.dbc67035.js"><link rel="prefetch" href="/assets/js/10.a775d731.js"><link rel="prefetch" href="/assets/js/100.793352e3.js"><link rel="prefetch" href="/assets/js/101.93a5f8bb.js"><link rel="prefetch" href="/assets/js/102.8fe288c9.js"><link rel="prefetch" href="/assets/js/103.3ba8eb3b.js"><link rel="prefetch" href="/assets/js/104.f88a17fa.js"><link rel="prefetch" href="/assets/js/105.995a53bd.js"><link rel="prefetch" href="/assets/js/106.e4adb465.js"><link rel="prefetch" href="/assets/js/107.6a66dc0f.js"><link rel="prefetch" href="/assets/js/108.d8b95fbe.js"><link rel="prefetch" href="/assets/js/109.9f97c8e0.js"><link rel="prefetch" href="/assets/js/11.b3a143f9.js"><link rel="prefetch" href="/assets/js/110.6a55a2b0.js"><link rel="prefetch" href="/assets/js/111.f365f51b.js"><link rel="prefetch" href="/assets/js/112.23a69bce.js"><link rel="prefetch" href="/assets/js/113.f76fe27c.js"><link rel="prefetch" href="/assets/js/114.396ab617.js"><link rel="prefetch" href="/assets/js/115.24dc44b3.js"><link rel="prefetch" href="/assets/js/116.4db063a6.js"><link rel="prefetch" href="/assets/js/117.234fa509.js"><link rel="prefetch" href="/assets/js/118.762c26ae.js"><link rel="prefetch" href="/assets/js/119.b498404b.js"><link rel="prefetch" href="/assets/js/12.bdc9b103.js"><link rel="prefetch" href="/assets/js/120.3debedff.js"><link rel="prefetch" href="/assets/js/121.5d1eeee0.js"><link rel="prefetch" href="/assets/js/122.858b7396.js"><link rel="prefetch" href="/assets/js/123.07b10a26.js"><link rel="prefetch" href="/assets/js/124.12cf523b.js"><link rel="prefetch" href="/assets/js/125.be140dcf.js"><link rel="prefetch" href="/assets/js/126.ec6bec0a.js"><link rel="prefetch" href="/assets/js/127.19a512ed.js"><link rel="prefetch" href="/assets/js/128.09231467.js"><link rel="prefetch" href="/assets/js/129.3d3667d5.js"><link rel="prefetch" href="/assets/js/13.3d75b565.js"><link rel="prefetch" href="/assets/js/130.37136180.js"><link rel="prefetch" href="/assets/js/131.ce5a1823.js"><link rel="prefetch" href="/assets/js/132.0bf2d4b8.js"><link rel="prefetch" href="/assets/js/133.8a7faef5.js"><link rel="prefetch" href="/assets/js/134.e79c3cb3.js"><link rel="prefetch" href="/assets/js/135.979221b8.js"><link rel="prefetch" href="/assets/js/136.083a11de.js"><link rel="prefetch" href="/assets/js/137.910df870.js"><link rel="prefetch" href="/assets/js/138.c984a534.js"><link rel="prefetch" href="/assets/js/139.b5ba10b5.js"><link rel="prefetch" href="/assets/js/14.8c4ccf68.js"><link rel="prefetch" href="/assets/js/140.5b4ff33e.js"><link rel="prefetch" href="/assets/js/141.5e39d1fb.js"><link rel="prefetch" href="/assets/js/142.e161d48a.js"><link rel="prefetch" href="/assets/js/143.53dbb4fe.js"><link rel="prefetch" href="/assets/js/144.605bf81b.js"><link rel="prefetch" href="/assets/js/145.ac0bd23a.js"><link rel="prefetch" href="/assets/js/146.35ab1adf.js"><link rel="prefetch" href="/assets/js/147.6dbfd1bf.js"><link rel="prefetch" href="/assets/js/148.103f2556.js"><link rel="prefetch" href="/assets/js/149.cd283ab0.js"><link rel="prefetch" href="/assets/js/15.b61b4fa1.js"><link rel="prefetch" href="/assets/js/150.31bba4d3.js"><link rel="prefetch" href="/assets/js/151.286cbc33.js"><link rel="prefetch" href="/assets/js/152.fc82f8a4.js"><link rel="prefetch" href="/assets/js/153.33a3cf28.js"><link rel="prefetch" href="/assets/js/154.96b2868b.js"><link rel="prefetch" href="/assets/js/155.fd31773a.js"><link rel="prefetch" href="/assets/js/156.7f222418.js"><link rel="prefetch" href="/assets/js/157.81213bf1.js"><link rel="prefetch" href="/assets/js/158.7470b9fe.js"><link rel="prefetch" href="/assets/js/159.bafbee37.js"><link rel="prefetch" href="/assets/js/16.41fdc9dc.js"><link rel="prefetch" href="/assets/js/160.2da76660.js"><link rel="prefetch" href="/assets/js/161.0c0bc249.js"><link rel="prefetch" href="/assets/js/162.8a532431.js"><link rel="prefetch" href="/assets/js/163.3fa72151.js"><link rel="prefetch" href="/assets/js/164.cd285366.js"><link rel="prefetch" href="/assets/js/165.41033881.js"><link rel="prefetch" href="/assets/js/166.fd6b241a.js"><link rel="prefetch" href="/assets/js/167.8a53c854.js"><link rel="prefetch" href="/assets/js/168.88cc6ae9.js"><link rel="prefetch" href="/assets/js/169.8a18d9df.js"><link rel="prefetch" href="/assets/js/17.32974a09.js"><link rel="prefetch" href="/assets/js/170.ed0b19ca.js"><link rel="prefetch" href="/assets/js/171.a357b446.js"><link rel="prefetch" href="/assets/js/172.37f81230.js"><link rel="prefetch" href="/assets/js/173.ad738587.js"><link rel="prefetch" href="/assets/js/174.6c1ca221.js"><link rel="prefetch" href="/assets/js/175.4af654b2.js"><link rel="prefetch" href="/assets/js/176.d7d5b406.js"><link rel="prefetch" href="/assets/js/177.1b6ff361.js"><link rel="prefetch" href="/assets/js/178.e34939d2.js"><link rel="prefetch" href="/assets/js/179.ac18e224.js"><link rel="prefetch" href="/assets/js/18.f2d22e96.js"><link rel="prefetch" href="/assets/js/180.06f4a808.js"><link rel="prefetch" href="/assets/js/181.6e7fcd2a.js"><link rel="prefetch" href="/assets/js/182.83cc6494.js"><link rel="prefetch" href="/assets/js/183.69d92232.js"><link rel="prefetch" href="/assets/js/184.34bc9080.js"><link rel="prefetch" href="/assets/js/185.b8df1bf9.js"><link rel="prefetch" href="/assets/js/186.03c9036f.js"><link rel="prefetch" href="/assets/js/187.b7629e30.js"><link rel="prefetch" href="/assets/js/188.9fcf827b.js"><link rel="prefetch" href="/assets/js/189.251906b4.js"><link rel="prefetch" href="/assets/js/19.944f084e.js"><link rel="prefetch" href="/assets/js/190.e6e3559c.js"><link rel="prefetch" href="/assets/js/191.bb5ae0b2.js"><link rel="prefetch" href="/assets/js/192.c594b285.js"><link rel="prefetch" href="/assets/js/193.455e539f.js"><link rel="prefetch" href="/assets/js/194.4b386eb0.js"><link rel="prefetch" href="/assets/js/195.d9bccf8a.js"><link rel="prefetch" href="/assets/js/197.2f90cbd4.js"><link rel="prefetch" href="/assets/js/198.7d45f853.js"><link rel="prefetch" href="/assets/js/199.35476566.js"><link rel="prefetch" href="/assets/js/2.264ce206.js"><link rel="prefetch" href="/assets/js/20.8209a208.js"><link rel="prefetch" href="/assets/js/200.2c799379.js"><link rel="prefetch" href="/assets/js/201.ad5540d7.js"><link rel="prefetch" href="/assets/js/202.3aa3be84.js"><link rel="prefetch" href="/assets/js/203.610bdd01.js"><link rel="prefetch" href="/assets/js/204.f1cddacf.js"><link rel="prefetch" href="/assets/js/205.7b348555.js"><link rel="prefetch" href="/assets/js/206.45625b67.js"><link rel="prefetch" href="/assets/js/207.01c96aa2.js"><link rel="prefetch" href="/assets/js/208.0e7226dc.js"><link rel="prefetch" href="/assets/js/209.4d3b4ef4.js"><link rel="prefetch" href="/assets/js/21.59a65aee.js"><link rel="prefetch" href="/assets/js/210.ec9d9c1c.js"><link rel="prefetch" href="/assets/js/211.35c3c93b.js"><link rel="prefetch" href="/assets/js/212.b52e7409.js"><link rel="prefetch" href="/assets/js/213.e8017903.js"><link rel="prefetch" href="/assets/js/214.efc1ee68.js"><link rel="prefetch" href="/assets/js/215.fa5d06ed.js"><link rel="prefetch" href="/assets/js/216.03ab31c5.js"><link rel="prefetch" href="/assets/js/217.d8cb5947.js"><link rel="prefetch" href="/assets/js/218.2ecefbc0.js"><link rel="prefetch" href="/assets/js/219.68ea6f5a.js"><link rel="prefetch" href="/assets/js/22.45f0537a.js"><link rel="prefetch" href="/assets/js/220.70633b78.js"><link rel="prefetch" href="/assets/js/221.017c9f3a.js"><link rel="prefetch" href="/assets/js/222.058eb9b2.js"><link rel="prefetch" href="/assets/js/223.c8578236.js"><link rel="prefetch" href="/assets/js/224.7ddf437d.js"><link rel="prefetch" href="/assets/js/225.264b5ee1.js"><link rel="prefetch" href="/assets/js/226.20d893ba.js"><link rel="prefetch" href="/assets/js/227.68d16a29.js"><link rel="prefetch" href="/assets/js/228.6ed4c02f.js"><link rel="prefetch" href="/assets/js/229.5e44f3ec.js"><link rel="prefetch" href="/assets/js/23.348148c7.js"><link rel="prefetch" href="/assets/js/230.484a9d2f.js"><link rel="prefetch" href="/assets/js/231.f9a7b3e5.js"><link rel="prefetch" href="/assets/js/232.8f5aa7a1.js"><link rel="prefetch" href="/assets/js/233.ce9e0cc2.js"><link rel="prefetch" href="/assets/js/234.80dbccad.js"><link rel="prefetch" href="/assets/js/235.686c5b03.js"><link rel="prefetch" href="/assets/js/236.ea660bc8.js"><link rel="prefetch" href="/assets/js/237.8c3bda1f.js"><link rel="prefetch" href="/assets/js/238.c3eed08a.js"><link rel="prefetch" href="/assets/js/239.eb714759.js"><link rel="prefetch" href="/assets/js/24.531389c6.js"><link rel="prefetch" href="/assets/js/240.bafa3804.js"><link rel="prefetch" href="/assets/js/241.ac914cd2.js"><link rel="prefetch" href="/assets/js/25.6f4f5681.js"><link rel="prefetch" href="/assets/js/26.b6a43310.js"><link rel="prefetch" href="/assets/js/27.f0c7f638.js"><link rel="prefetch" href="/assets/js/28.964fc71a.js"><link rel="prefetch" href="/assets/js/29.22a20c74.js"><link rel="prefetch" href="/assets/js/30.6817489c.js"><link rel="prefetch" href="/assets/js/31.12448ed0.js"><link rel="prefetch" href="/assets/js/32.b9cd368e.js"><link rel="prefetch" href="/assets/js/33.9d6a6d82.js"><link rel="prefetch" href="/assets/js/34.fe2677db.js"><link rel="prefetch" href="/assets/js/35.a2503289.js"><link rel="prefetch" href="/assets/js/36.d87cebfe.js"><link rel="prefetch" href="/assets/js/37.530e3d74.js"><link rel="prefetch" href="/assets/js/38.0dce521e.js"><link rel="prefetch" href="/assets/js/39.456ad7c4.js"><link rel="prefetch" href="/assets/js/40.041ed3c1.js"><link rel="prefetch" href="/assets/js/41.68fa3813.js"><link rel="prefetch" href="/assets/js/42.9888c130.js"><link rel="prefetch" href="/assets/js/43.9857547c.js"><link rel="prefetch" href="/assets/js/44.dce7db40.js"><link rel="prefetch" href="/assets/js/45.413cf12d.js"><link rel="prefetch" href="/assets/js/46.03d837e3.js"><link rel="prefetch" href="/assets/js/47.e6346d8f.js"><link rel="prefetch" href="/assets/js/48.ca27acac.js"><link rel="prefetch" href="/assets/js/49.d676a69f.js"><link rel="prefetch" href="/assets/js/50.3870a023.js"><link rel="prefetch" href="/assets/js/51.a81e6b74.js"><link rel="prefetch" href="/assets/js/52.2ad29576.js"><link rel="prefetch" href="/assets/js/53.23e7cc96.js"><link rel="prefetch" href="/assets/js/54.7bb15640.js"><link rel="prefetch" href="/assets/js/55.486666c0.js"><link rel="prefetch" href="/assets/js/56.700c6a13.js"><link rel="prefetch" href="/assets/js/57.4c3ad8da.js"><link rel="prefetch" href="/assets/js/58.22ba7a5f.js"><link rel="prefetch" href="/assets/js/59.c02ecbd0.js"><link rel="prefetch" href="/assets/js/6.3c3a8ef6.js"><link rel="prefetch" href="/assets/js/60.fc2291f4.js"><link rel="prefetch" href="/assets/js/61.931acbc7.js"><link rel="prefetch" href="/assets/js/62.a4b5ce68.js"><link rel="prefetch" href="/assets/js/63.ba1743ce.js"><link rel="prefetch" href="/assets/js/64.cd13870f.js"><link rel="prefetch" href="/assets/js/65.4caa9b5f.js"><link rel="prefetch" href="/assets/js/66.c3fcf9ef.js"><link rel="prefetch" href="/assets/js/67.ca8812c6.js"><link rel="prefetch" href="/assets/js/68.6ba69b85.js"><link rel="prefetch" href="/assets/js/69.ba8f8c69.js"><link rel="prefetch" href="/assets/js/7.52bd6e6a.js"><link rel="prefetch" href="/assets/js/70.4171631a.js"><link rel="prefetch" href="/assets/js/71.bd591883.js"><link rel="prefetch" href="/assets/js/72.d9ded673.js"><link rel="prefetch" href="/assets/js/73.90465489.js"><link rel="prefetch" href="/assets/js/74.40b607a6.js"><link rel="prefetch" href="/assets/js/75.3c854954.js"><link rel="prefetch" href="/assets/js/76.d4a90f9d.js"><link rel="prefetch" href="/assets/js/77.c5f36263.js"><link rel="prefetch" href="/assets/js/78.8cdf215b.js"><link rel="prefetch" href="/assets/js/79.44a711cf.js"><link rel="prefetch" href="/assets/js/8.5c6bb16c.js"><link rel="prefetch" href="/assets/js/80.bd2c8928.js"><link rel="prefetch" href="/assets/js/81.1f89bcf7.js"><link rel="prefetch" href="/assets/js/82.6cd16df9.js"><link rel="prefetch" href="/assets/js/83.fe9c6574.js"><link rel="prefetch" href="/assets/js/84.e88a4655.js"><link rel="prefetch" href="/assets/js/85.517976c2.js"><link rel="prefetch" href="/assets/js/86.9d39bf3f.js"><link rel="prefetch" href="/assets/js/87.904e76d4.js"><link rel="prefetch" href="/assets/js/88.caa214fb.js"><link rel="prefetch" href="/assets/js/89.a4fa8341.js"><link rel="prefetch" href="/assets/js/9.6c0ed10e.js"><link rel="prefetch" href="/assets/js/90.0c6766ae.js"><link rel="prefetch" href="/assets/js/91.230a4018.js"><link rel="prefetch" href="/assets/js/92.ffde6c4c.js"><link rel="prefetch" href="/assets/js/93.899f185e.js"><link rel="prefetch" href="/assets/js/94.38b52a15.js"><link rel="prefetch" href="/assets/js/95.ee81eb1b.js"><link rel="prefetch" href="/assets/js/96.e946c6f1.js"><link rel="prefetch" href="/assets/js/97.daaf8ed8.js"><link rel="prefetch" href="/assets/js/98.4b417c71.js"><link rel="prefetch" href="/assets/js/99.38271524.js">
    <link rel="stylesheet" href="/assets/css/0.styles.14f02b24.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/header.png" alt="高小哥漫谈前端" class="logo"> <span class="site-name can-hide">高小哥漫谈前端</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title">工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具" class="mobile-dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://uibuilder.gaogangsever.cn/ui-builder/index.html#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  页面构建器
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://uibuilder.gaogangsever.cn/flows/index.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  流程图
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/parse-jsx-to-css" target="_blank" rel="noopener noreferrer" class="nav-link external">
  解析JSX/Vue中的class到less/sass/css中
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/chengdu_house_tax" target="_blank" rel="noopener noreferrer" class="nav-link external">
  成都二手房工具集
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://app.quicktype.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  将json序列化为代码
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/tools/index.html" class="nav-link">
  其他推荐
</a></li></ul></div></div><div class="nav-item"><a href="/javascript/index.html" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/vue/index.html" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/react/index.html" class="nav-link">
  React/RN
</a></div><div class="nav-item"><a href="/nodejs/index.html" class="nav-link">
  AI/Node
</a></div><div class="nav-item"><a href="/android/index.html" class="nav-link">
  Android
</a></div><div class="nav-item"><a href="/ios/index.html" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/architecture/index.html" class="nav-link">
  UML/思考/设计模式
</a></div><div class="nav-item"><a href="/other/index.html" class="nav-link">
  Docker/SQL/Git/Nginx
</a></div><div class="nav-item"><a href="/lowcode/index.html" class="nav-link">
  低代码
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开源" class="dropdown-title"><span class="title">开源</span> <span class="arrow down"></span></button> <button type="button" aria-label="开源" class="mobile-dropdown-title"><span class="title">开源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/article/oview/index.html" class="nav-link">
  图表库oView
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/luckly_recyclerview" target="_blank" rel="noopener noreferrer" class="nav-link external">
  lucky_recyclerview
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/luckly_popup_window" target="_blank" rel="noopener noreferrer" class="nav-link external">
  lucky_popup_window
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/lucky_tools/blob/master/packages/mendix-cli/README.md" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue开发Mendix组件脚手架
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/cocos-webpack-web" target="_blank" rel="noopener noreferrer" class="nav-link external">
  cocos web端开发
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/ui-designer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  ui 构建器
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/KotlinGank" target="_blank" rel="noopener noreferrer" class="nav-link external">
  kotlin App
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/tensorflow_object_detection" target="_blank" rel="noopener noreferrer" class="nav-link external">
  tensorflow object detection
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/react-native-file-hash-plugin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  react-native-file-hash-plugin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="https://github.com/MrGaoGang/mrgaogang.github.io/issues" target="_blank" rel="noopener noreferrer" class="nav-link external">
  issues
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/MrGaoGang/mrgaogang.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title">工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具" class="mobile-dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://uibuilder.gaogangsever.cn/ui-builder/index.html#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  页面构建器
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://uibuilder.gaogangsever.cn/flows/index.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  流程图
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/parse-jsx-to-css" target="_blank" rel="noopener noreferrer" class="nav-link external">
  解析JSX/Vue中的class到less/sass/css中
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/chengdu_house_tax" target="_blank" rel="noopener noreferrer" class="nav-link external">
  成都二手房工具集
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://app.quicktype.io/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  将json序列化为代码
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="/tools/index.html" class="nav-link">
  其他推荐
</a></li></ul></div></div><div class="nav-item"><a href="/javascript/index.html" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/vue/index.html" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/react/index.html" class="nav-link">
  React/RN
</a></div><div class="nav-item"><a href="/nodejs/index.html" class="nav-link">
  AI/Node
</a></div><div class="nav-item"><a href="/android/index.html" class="nav-link">
  Android
</a></div><div class="nav-item"><a href="/ios/index.html" class="nav-link">
  iOS
</a></div><div class="nav-item"><a href="/architecture/index.html" class="nav-link">
  UML/思考/设计模式
</a></div><div class="nav-item"><a href="/other/index.html" class="nav-link">
  Docker/SQL/Git/Nginx
</a></div><div class="nav-item"><a href="/lowcode/index.html" class="nav-link">
  低代码
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开源" class="dropdown-title"><span class="title">开源</span> <span class="arrow down"></span></button> <button type="button" aria-label="开源" class="mobile-dropdown-title"><span class="title">开源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/article/oview/index.html" class="nav-link">
  图表库oView
</a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/luckly_recyclerview" target="_blank" rel="noopener noreferrer" class="nav-link external">
  lucky_recyclerview
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/luckly_popup_window" target="_blank" rel="noopener noreferrer" class="nav-link external">
  lucky_popup_window
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/lucky_tools/blob/master/packages/mendix-cli/README.md" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue开发Mendix组件脚手架
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/cocos-webpack-web" target="_blank" rel="noopener noreferrer" class="nav-link external">
  cocos web端开发
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/ui-designer" target="_blank" rel="noopener noreferrer" class="nav-link external">
  ui 构建器
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/KotlinGank" target="_blank" rel="noopener noreferrer" class="nav-link external">
  kotlin App
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/tensorflow_object_detection" target="_blank" rel="noopener noreferrer" class="nav-link external">
  tensorflow object detection
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/MrGaoGang/react-native-file-hash-plugin" target="_blank" rel="noopener noreferrer" class="nav-link external">
  react-native-file-hash-plugin
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="https://github.com/MrGaoGang/mrgaogang.github.io/issues" target="_blank" rel="noopener noreferrer" class="nav-link external">
  issues
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/MrGaoGang/mrgaogang.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Fiber的理解</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#前言" class="sidebar-link">前言</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#fiber-出现的背景" class="sidebar-link">Fiber 出现的背景</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#fiber-是什么" class="sidebar-link">Fiber 是什么</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#fiber-如何解决问题的" class="sidebar-link">Fiber 如何解决问题的</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#fiber的核心目标及特性" class="sidebar-link">Fiber的核心目标及特性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#核心目标" class="sidebar-link">核心目标</a></li><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#关键特性" class="sidebar-link">关键特性</a></li></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#fiber-实现原理" class="sidebar-link">Fiber 实现原理</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#fiber-架构核心" class="sidebar-link">Fiber 架构核心</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#scheduler-调度器" class="sidebar-link">Scheduler 调度器</a></li><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#reconciler-协调器" class="sidebar-link">Reconciler 协调器</a></li><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#renderer-渲染器" class="sidebar-link">Renderer 渲染器</a></li></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#fiber-架构对生命周期的影响" class="sidebar-link">Fiber 架构对生命周期的影响</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#fiber-更新过程" class="sidebar-link">Fiber 更新过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#协调阶段-reconciliation-render" class="sidebar-link">协调阶段 reconciliation/render</a></li><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#commit-提交阶段" class="sidebar-link">commit 提交阶段</a></li></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#fiber-tree-与-workinprogress-tree" class="sidebar-link">Fiber tree 与 workInProgress tree</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#优先级策略" class="sidebar-link">优先级策略</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#fiber-reconciliation-阶段中的-diff-算法" class="sidebar-link">Fiber reconciliation 阶段中的 diff 算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#代码部分" class="sidebar-link">代码部分</a></li><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#diff-总结" class="sidebar-link">diff 总结</a></li></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#fiber总结" class="sidebar-link">Fiber总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#如何解决主线程长时间占用问题" class="sidebar-link">如何解决主线程长时间占用问题?</a></li><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#_1-拆什么-什么不能拆" class="sidebar-link">1. 拆什么？什么不能拆？</a></li><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#_2-怎么拆" class="sidebar-link">2. 怎么拆？</a></li><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#_3-如何调度任务" class="sidebar-link">3. 如何调度任务？</a></li><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#_4-如何中断-断点恢复" class="sidebar-link">4. 如何中断/断点恢复？</a></li><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#_5-如何收集任务结果" class="sidebar-link">5. 如何收集任务结果？</a></li><li class="sidebar-sub-header"><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#举一反三" class="sidebar-link">举一反三</a></li></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#源码简析" class="sidebar-link">源码简析</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html#参考" class="sidebar-link">参考</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="ads-main"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAMAAACdt4HsAAAAgVBMVEUAAABvb29wcHBwcHBwcHBzc3NwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBvb29vb29ubm5wcHBwcHBwcHBwcHBwcHBubm5wcHBwcHBwcHBvb29wcHBwcHBiYmJvb29qampwcHBwcHDt3O1jAAAAKnRSTlMAVL/WqSr05MZizEAz+97CuFhL77GAd0QuEbyNhHNwPJsl6J5sXQQcDKLHDJAOAAABp0lEQVRYw+2U2ZKCMBBFA4QdHRHZBBR3p///A6csEloTghHfpjhPQFefQLgdMjMzI2PEX/YD+Hh3jStqWo5jmbSKS83+3lD6dAHPrLJIqx/AeLRnLkgsqsO4gEJHfm0SGCSpSy0DvrtLmzBuWs8BRrB+b0DSkBduVS+tRw0bQMzwuRJ5wNhoGqhYOgHjR8tA5VL6mcGQS7/AqEYNq2eDQSE48XSGuL2ahoJdblnFBI5PBrAN0bAExrIr7DAgQ6G0AA0iWbcEyD8JyQAWPGdbEMnZGj07InB3YcwQ95uAX4XgFjsqw04UQCEISng1mEMCDxBpG2tmyNEgrbfEByYRuQds6LnhBxCre+Tg6bJXnUiyAYN9Ef6rat4SPsge9mM+Rmb6cGTlo2iI2StyEsUBewaVwX/9pAtR0PRZ53sUQMeZkFSdQsRXGrIUtI5Fw1EYkJaMkrs87NGwoSZviALR4AFCC/Key1Y24KRosaZdgCMhkzHRZt+6D0MhGHzyAbbfWr3BxDx8hm0LhoZMAw3plwbLniy4mtg/jdLD/mncsH8iNpmZ+bf8ATswhv7fNYeiAAAAAElFTkSuQmCC" class="btn-control"> <img src="https://camo.githubusercontent.com/01448f33e0bc34a83317f39bb3a1df723e109d4194e0259b7345775fe99968d5/68747470733a2f2f70312d6a75656a696e2e62797465696d672e636f6d2f746f732d636e2d692d6b3375316662706663702f33306666633738643332313434323632623536633633653230323261656163307e74706c762d6b3375316662706663702d7a6f6f6d2d312e696d616765" class="my-wechat-m" style="display:;"> </div> <div class="theme-default-content content__default"><h1 id="fiber的理解"><a href="#fiber的理解" class="header-anchor">#</a> Fiber的理解</h1> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>本文作为自己深入学习 <code>React Fiber</code>(React v16.8.6)的理解,本篇仅介绍大致流程,Fiber 详细源码本文不作细节描述。</p> <h2 id="fiber-出现的背景"><a href="#fiber-出现的背景" class="header-anchor">#</a> <code>Fiber</code> 出现的背景</h2> <p>首先要知道的是,JavaScript 引擎和页面渲染引擎<strong>两个线程是互斥的</strong>,当其中一个线程执行时,另一个线程只能挂起等待。</p> <p>在这样的机制下,<strong>如果 <code>JavaScript</code> 线程长时间地占用了主线程,那么渲染层面的更新就不得不长时间地等待,界面长时间不更新,会导致页面响应度变差,用户可能会感觉到卡顿</strong>。</p> <p>而这正是 React 15 的 <code>Stack Reconciler</code> 所面临的问题,即是 <code>JavaScript</code> 对主线程的超时占用问题。<code>Stack Reconciler</code> 是一个同步的递归过程,使用的是 <code>JavaScript</code> 引擎自身的函数调用栈,它会一直执行到栈空为止,所以当 <code>React</code> 在渲染组件时,从开始到渲染完成整个过程是一气呵成的。如果渲染的组件比较庞大,js 执行会占据主线程较长时间,会导致页面响应度变差。</p> <p>而且所有的任务都是按照先后顺序,没有区分优先级,这样就会导致优先级比较高的任务无法被优先执行。</p> <h2 id="fiber-是什么"><a href="#fiber-是什么" class="header-anchor">#</a> <code>Fiber</code> 是什么</h2> <p><code>Fiber</code> 的中文翻译叫纤程,与进程、线程同为程序执行过程,Fiber 就是比线程还要纤细的一个过程。纤程意在对渲染过程实现进行更加精细的控制。</p> <p>从架构角度来看,<code>Fiber</code> 是对 <code>React</code> 核心算法（即调和过程）的重写。</p> <p>从编码角度来看,<code>Fiber</code> 是 <code>React</code> 内部所定义的一种数据结构,它是 <code>Fiber</code> 树结构的节点单位,也就是 React 16 新架构下的&quot;虚拟 DOM&quot;。</p> <p>一个 fiber 就是一个 <code>JavaScript</code> 对象,Fiber 的数据结构如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>type Fiber <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// 用于标记fiber的WorkTag类型,主要表示当前fiber代表的组件类型如FunctionComponent、ClassComponent等</span>
  <span class="token literal-property property">tag</span><span class="token operator">:</span> WorkTag<span class="token punctuation">,</span>
  <span class="token comment">// ReactElement里面的key</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span>
  <span class="token comment">// ReactElement.type,调用`createElement`的第一个参数</span>
  <span class="token literal-property property">elementType</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// The resolved function/class/ associated with this fiber.</span>
  <span class="token comment">// 表示当前代表的节点类型</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// 表示当前FiberNode对应的element组件实例</span>
  <span class="token literal-property property">stateNode</span><span class="token operator">:</span> any<span class="token punctuation">,</span>

  <span class="token comment">// 指向他在Fiber节点树中的`parent`,用来在处理完这个节点之后向上返回</span>
  <span class="token keyword">return</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 指向自己的第一个子节点</span>
  <span class="token literal-property property">child</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 指向自己的兄弟结构,兄弟节点的return指向同一个父节点</span>
  <span class="token literal-property property">sibling</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">index</span><span class="token operator">:</span> number<span class="token punctuation">,</span>

  <span class="token literal-property property">ref</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">handle</span><span class="token operator">:</span> mixed</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> <span class="token literal-property property">_stringRef</span><span class="token operator">:</span> <span class="token operator">?</span>string <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">|</span> RefObject<span class="token punctuation">,</span>

  <span class="token comment">// 当前处理过程中的组件props对象</span>
  <span class="token literal-property property">pendingProps</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// 上一次渲染完成之后的props</span>
  <span class="token literal-property property">memoizedProps</span><span class="token operator">:</span> any<span class="token punctuation">,</span>

  <span class="token comment">// 该Fiber对应的组件产生的Update会存放在这个队列里面</span>
  <span class="token literal-property property">updateQueue</span><span class="token operator">:</span> UpdateQueue<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 上一次渲染的时候的state</span>
  <span class="token literal-property property">memoizedState</span><span class="token operator">:</span> any<span class="token punctuation">,</span>

  <span class="token comment">// 一个列表,存放这个Fiber依赖的context</span>
  <span class="token literal-property property">firstContextDependency</span><span class="token operator">:</span> ContextDependency<span class="token operator">&lt;</span>mixed<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token literal-property property">mode</span><span class="token operator">:</span> TypeOfMode<span class="token punctuation">,</span>

  <span class="token comment">// Effect</span>
  <span class="token comment">// 用来记录Side Effect</span>
  <span class="token literal-property property">effectTag</span><span class="token operator">:</span> SideEffectTag<span class="token punctuation">,</span>

  <span class="token comment">// 单链表用来快速查找下一个side effect</span>
  <span class="token literal-property property">nextEffect</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 子树中第一个side effect</span>
  <span class="token literal-property property">firstEffect</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 子树中最后一个side effect</span>
  <span class="token literal-property property">lastEffect</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">// 代表任务在未来的哪个时间点应该被完成,之后版本改名为 lanes</span>
  <span class="token literal-property property">expirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>

  <span class="token comment">// 快速确定子树中是否有不在等待的变化</span>
  <span class="token literal-property property">childExpirationTime</span><span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span>

  <span class="token comment">// fiber的版本池,即记录fiber更新过程,便于恢复</span>
  <span class="token literal-property property">alternate</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Fiber</span><span class="token template-punctuation string">`</span></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

</code></pre></div><blockquote><p>在 2020 年 5 月,以 expirationTime 属性为代表的优先级模型被 lanes 取代。</p></blockquote> <h2 id="fiber-如何解决问题的"><a href="#fiber-如何解决问题的" class="header-anchor">#</a> <code>Fiber</code> 如何解决问题的</h2> <p><code>Fiber</code> <strong>把一个渲染任务分解为多个渲染任务</strong>,而不是一次性完成,把每一个分割得很细的任务视作一个&quot;执行单元&quot;,React 就会检查现在还剩多少时间,如果没有时间就将控制权让出去,故任务会被分散到多个帧里面,中间可以返回至主进程控制执行其他任务,最终实现更流畅的用户体验。</p> <p>即是实现了&quot;增量渲染&quot;,实现了可中断与恢复,恢复后也可以复用之前的中间状态,并给不同的任务赋予不同的优先级,其中每个任务更新单元为 React Element 对应的 <code>Fiber</code> 节点。</p> <h2 id="fiber的核心目标及特性"><a href="#fiber的核心目标及特性" class="header-anchor">#</a> <code>Fiber</code>的核心目标及特性</h2> <h3 id="核心目标"><a href="#核心目标" class="header-anchor">#</a> 核心目标</h3> <p>核心目标：<strong>扩大其适用性，包括动画，布局和手势</strong>。分为 5 个具体目标:</p> <ul><li><p>把可中断的工作拆分成小任务</p></li> <li><p>对正在做的工作调整优先次序、重做、复用上次（做了一半的）成果</p></li> <li><p>在父子任务之间从容切换（yield back and forth），以支持 React 执行过程中的布局刷新</p></li> <li><p>支持 render()返回多个元素</p></li> <li><p>更好地支持 error boundary</p></li></ul> <h3 id="关键特性"><a href="#关键特性" class="header-anchor">#</a> 关键特性</h3> <p>Fiber 的关键特性如下：</p> <ul><li><p><strong>增量渲染（把渲染任务拆分成块，匀到多帧）</strong></p></li> <li><p><strong>更新时能够暂停，终止，复用渲染任务</strong></p></li> <li><p><strong>给不同类型的更新赋予优先级</strong></p></li> <li><p><strong>并发方面新的基础能力</strong></p></li></ul> <p>增量渲染用来解决掉帧的问题，渲染任务拆分之后，每次只做一小段，做完一段就把时间控制权交还给主线程，而不像之前长时间占用。这种策略叫做 cooperative scheduling（合作式调度），操作系统的 3 种任务调度策略之一（Firefox 还对真实 DOM 应用了这项技术）</p> <p>另外，React 自身的<em>killer feature</em>是 virtual DOM，2 个原因：</p> <ul><li><p>coding UI 变简单了（不用关心浏览器应该怎么做，而是把下一刻的 UI 描述给 React 听）</p></li> <li><p>既然 DOM 能 virtual，别的（硬件、VR、native App）也能</p></li></ul> <p>React 实现上分为 2 部分：</p> <ul><li><p>reconciler 寻找某时刻前后两版 UI 的差异。包括之前的 Stack reconciler 与现在的 Fiber reconciler</p></li> <li><p>renderer 插件式的，平台相关的部分。包括 React DOM、React Native、React ART、ReactHardware、ReactAframe、React-pdf、ReactThreeRenderer、ReactBlessed 等等</p></li></ul> <p><strong>这一波是对 reconciler 的彻底改造，对 killer feature 的增强</strong></p> <h2 id="fiber-实现原理"><a href="#fiber-实现原理" class="header-anchor">#</a> <code>Fiber</code> 实现原理</h2> <p>实现的方式是<code>requestIdleCallback</code>这一 API,但 React 团队 polyfill 了这个 API,使其对比原生的浏览器兼容性更好且拓展了特性。</p> <blockquote><p><code>window.requestIdleCallback()</code>方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作,而不会影响延迟关键事件,如动画和输入响应。函数一般会按先进先调用的顺序执行,然而,如果回调函数指定了执行超时时间 timeout,则有可能为了在超时前执行函数而打乱执行顺序。</p></blockquote> <p><code>requestIdleCallback</code>回调的执行的前提条件是当前浏览器处于空闲状态。</p> <p>即<code>requestIdleCallback</code>的作用是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务。首先 React 中任务切割为多个步骤,分批完成。在完成一部分任务之后,将控制权交回给浏览器,让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间,再继续之前 React 未完成的任务,是一种合作式调度。</p> <p>简而言之,由浏览器给我们分配执行时间片,我们要按照约定在这个时间内执行完毕,并将控制权还给浏览器。</p> <p>React 16 的<code>Reconciler</code>基于 <code>Fiber</code> 节点实现,被称为 <code>Fiber</code> Reconciler。</p> <p>作为静态的数据结构来说,每个 <code>Fiber</code> 节点对应一个 React element,保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。</p> <p>作为动态的工作单元来说,每个 <code>Fiber</code> 节点保存了本次更新中该组件改变的状态、要执行的工作。</p> <p>每个 <code>Fiber</code> 节点有个对应的 React element,多个 <code>Fiber</code> 节点是如何连接形成树呢？靠如下三个属性：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 指向父级Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 指向子Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 指向右边第一个兄弟Fiber节点</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="fiber-架构核心"><a href="#fiber-架构核心" class="header-anchor">#</a> <code>Fiber</code> 架构核心</h2> <p><code>Fiber</code> 架构可以分为三层：</p> <ul><li>Scheduler 调度器 —— 调度任务的优先级,高优任务优先进入 Reconciler</li> <li>Reconciler 协调器 —— 负责找出变化的组件</li> <li>Renderer 渲染器 —— 负责将变化的组件渲染到页面上</li></ul> <p>相比 React15,React16 多了<strong>Scheduler（调度器）</strong>,调度器的作用是调度更新的优先级。</p> <p>在新的架构模式下,工作流如下：</p> <ul><li>每个更新任务都会被赋予一个优先级。</li> <li>当更新任务抵达调度器时,高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；</li> <li>此时若有新的更新任务（记为 B）抵达调度器,调度器会检查它的优先级,若发现 B 的优先级高于当前任务 A,那么当前处于 Reconciler 层的 A 任务就会被中断,调度器会将 B 任务推入 Reconciler 层。</li> <li>当 B 任务完成渲染后,新一轮的调度开始,之前被中断的 A 任务将会被重新推入 Reconciler 层,继续它的渲染之旅,即“可恢复”。</li></ul> <p><strong><code>Fiber</code> 架构的核心即是&quot;可中断&quot;、&quot;可恢复&quot;、&quot;优先级&quot;</strong></p> <h3 id="scheduler-调度器"><a href="#scheduler-调度器" class="header-anchor">#</a> Scheduler 调度器</h3> <p>这个需要上面提到的<code>requestIdleCallback</code>,React 团队实现了功能更完备的 <code>requestIdleCallback</code> polyfill,这就是 Scheduler。除了在空闲时触发回调的功能外,Scheduler 还提供了多种调度优先级供任务设置。</p> <ul><li><a href="https://juejin.cn/post/6953804914715803678" target="_blank" rel="noopener noreferrer">React Scheduler 为什么使用MessageChannel ？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>React Scheduler 使用 MessageChannel 的原因为：<strong>生成宏任务</strong>，实现：</p> <ol><li>将主线程还给浏览器，以便浏览器更新页面。</li> <li>浏览器更新页面后继续执行未完成的任务。</li></ol> <p><strong>为什么不使用微任务呢？</strong></p> <ol><li>微任务将在页面更新前全部执行完，所以达不到「将主线程还给浏览器」的目的。</li></ol> <p><strong>为什么不使用 <code>setTimeout(fn, 0)</code> 呢？</strong></p> <ol><li>递归的 <code>setTimeout()</code> 调用会使调用间隔变为 4ms，导致浪费了 4ms。</li></ol> <p><strong>为什么不使用 <code>rAF()</code> 呢？</strong></p> <blockquote><p>不属于微任务也不属于宏任务，是属于任务。是一个在重绘之前执行的一个操作，而重绘操作一般是宏任务之前、微任务之后执行</p></blockquote> <ol><li>如果上次任务调度不是 <code>rAF()</code> 触发的，将导致在当前帧更新前进行两次任务调度。</li> <li>页面更新的时间不确定，如果浏览器间隔了 10ms 才更新页面，那么这 10ms 就浪费了。</li></ol> <ul><li><a href="https://juejin.cn/post/7007613737012035592" target="_blank" rel="noopener noreferrer">React源码解析之Scheduler<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js" target="_blank" rel="noopener noreferrer">Scheduler 源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h3 id="reconciler-协调器"><a href="#reconciler-协调器" class="header-anchor">#</a> Reconciler 协调器</h3> <p>在 React 15 中是递归处理虚拟 DOM 的,React 16 则是变成了可以中断的循环过程,每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Perform work until Scheduler asks us to yield</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// workInProgress表示当前工作进度的树。</span>
    workInProgress <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>React 16 是如何解决中断更新时 DOM 渲染不完全的问题呢？</p> <p>在 React 16 中,<code>Reconciler</code>与<code>Renderer</code>不再是交替工作。当<code>Scheduler</code>将任务交给<code>Reconciler</code>后,<code>Reconciler</code>会为变化的虚拟 DOM 打上的标记。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> Placement <span class="token operator">=</span> <span class="token comment">/*             */</span> <span class="token number">0b0000000000010</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Update <span class="token operator">=</span> <span class="token comment">/*                */</span> <span class="token number">0b0000000000100</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> PlacementAndUpdate <span class="token operator">=</span> <span class="token comment">/*    */</span> <span class="token number">0b0000000000110</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> Deletion <span class="token operator">=</span> <span class="token comment">/*              */</span> <span class="token number">0b0000000001000</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>Placement</code>表示插入操作</li> <li><code>PlacementAndUpdate</code>表示替换操作</li> <li><code>Update</code>表示更新操作</li> <li><code>Deletion</code>表示删除操作</li></ul> <p>整个<code>Scheduler</code>与<code>Reconciler</code>的工作都在内存中进行,所以即使反复中断,用户也不会看见更新不完全的 DOM。只有当所有组件都完成<code>Reconciler</code>的工作,才会统一交给<code>Renderer</code>。</p> <h3 id="renderer-渲染器"><a href="#renderer-渲染器" class="header-anchor">#</a> Renderer 渲染器</h3> <p><code>Renderer</code>根据<code>Reconciler</code>为虚拟 DOM 打的标记,同步执行对应的 DOM 操作。</p> <h2 id="fiber-架构对生命周期的影响"><a href="#fiber-架构对生命周期的影响" class="header-anchor">#</a> <code>Fiber</code> 架构对生命周期的影响</h2> <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8eb7f64f3f94a9f8038949001284385~tplv-k3u1fbpfcp-watermark.image" alt=""></p> <ol><li>render 阶段：纯净且没有副作用,可能会被 React 暂停、终止或重新启动。</li> <li>pre-commit 阶段：可以读取 DOM。</li> <li>commit 阶段：可以使用 DOM,运行副作用,安排更新。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 第1阶段 render/reconciliation</span>
componentWillMount<span class="token punctuation">;</span>
componentWillReceiveProps<span class="token punctuation">;</span>
shouldComponentUpdate<span class="token punctuation">;</span>
componentWillUpdate<span class="token punctuation">;</span>

<span class="token comment">// 第2阶段 commit</span>
componentDidMount<span class="token punctuation">;</span>
componentDidUpdate<span class="token punctuation">;</span>
componentWillUnmount<span class="token punctuation">;</span>
</code></pre></div><p>其中 pre-commit 和 commit 从大阶段上来看都属于 commit 阶段。</p> <p>在 render 阶段,React 主要是在内存中做计算,明确 DOM 树的更新点；而 commit 阶段,则负责把 render 阶段生成的更新真正地执行掉。</p> <p>新老两种架构对 React 生命周期的影响主要在 render 这个阶段,这个影响是通过增加 Scheduler 层和改写 Reconciler 层来实现的。</p> <p>在 render 阶段,一个庞大的更新任务被分解为了一个个的工作单元,这些工作单元有着不同的优先级,React 可以根据优先级的高低去实现工作单元的打断和恢复。</p> <p>之前写过一篇文章关于为什么 React 一些旧生命周期函数打算废弃的原因：<a href="https://juejin.cn/post/6900703477480685582" target="_blank" rel="noopener noreferrer">谈谈对 React 新旧生命周期的理解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>而这次从 Firber 机制 render 阶段的角度看这三个生命周期,这三个生命周期的共同特点是都处于 render 阶段：</p> <div class="language- extra-class"><pre class="language-text"><code>componentWillMount
componentWillUpdate
componentWillReceiveProps

</code></pre></div><p>由于 render 阶段是允许暂停、终止和重启的,这就导致 render 阶段的生命周期都有可能被重复执行,故也是废弃他们的原因之一。</p> <h2 id="fiber-更新过程"><a href="#fiber-更新过程" class="header-anchor">#</a> <code>Fiber</code> 更新过程</h2> <p>虚拟 DOM 更新过程分为 2 个阶段：</p> <ul><li><strong>render/reconciliation 协调阶段(可中断/异步)</strong>：通过 Diff 算法找出所有节点变更,例如节点新增、删除、属性变更等等, 获得需要更新的节点信息,对应早期版本的 Diff 过程。</li> <li><strong>commit 提交阶段(不可中断/同步)</strong>：将需要更新的节点一次过批量更新,对应早期版本的 patch 过程。</li></ul> <h3 id="协调阶段-reconciliation-render"><a href="#协调阶段-reconciliation-render" class="header-anchor">#</a> 协调阶段 reconciliation/render</h3> <p>在协调阶段: 以 fiber tree 为蓝本，把每个 fiber 作为一个工作单元，自顶向下逐节点构造<strong>workInProgress tree</strong>（构建中的新 fiber tree）</p> <p>该阶段开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// performSyncWorkOnRoot会调用该方法</span>
<span class="token keyword">function</span> <span class="token function">workLoopSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// performConcurrentWorkOnRoot会调用该方法</span>
<span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它们唯一的区别是是否调用<code>shouldYield</code>。如果当前浏览器帧没有剩余时间,<code>shouldYield</code>会中止循环,直到浏览器有空闲时间后再继续遍历。</p> <p><code>workInProgress</code>代表当前已创建的 workInProgress fiber。</p> <p><code>performUnitOfWork</code>方法将触发对 <code>beginWork</code> 的调用,进而实现对新 <code>Fiber</code> 节点的创建。若 <code>beginWork</code> 所创建的 <code>Fiber</code> 节点不为空,则 <code>performUniOfWork</code> 会用这个新的 <code>Fiber</code> 节点来更新 <code>workInProgress</code> 的值,为下一次循环做准备。</p> <p>通过循环调用 <code>performUnitOfWork</code> 来触发 <code>beginWork</code>,新的 <code>Fiber</code> 节点就会被不断地创建。当 <code>workInProgress</code> 终于为空时,说明没有新的节点可以创建了,也就意味着已经完成对整棵 <code>Fiber</code> 树的构建。</p> <p>我们知道 <code>Fiber</code> Reconciler 是从 Stack Reconciler 重构而来,通过遍历的方式实现可中断的递归,所以<code>performUnitOfWork</code>的工作可以分为两部分：&quot;递&quot;和&quot;归&quot;。</p> <p><strong>&quot;递阶段&quot;</strong></p> <p>首先从 rootFiber 开始向下深度优先遍历。为遍历到的每个 <code>Fiber</code> 节点调用<code>beginWork</code>方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>
  <span class="token literal-property property">current</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Fiber</span><span class="token template-punctuation string">`</span></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token comment">// 当前组件对应的Fiber节点在上一次更新时的Fiber节点</span>
  <span class="token literal-property property">workInProgress</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Fiber</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token comment">// 当前组件对应的Fiber节点</span>
  <span class="token literal-property property">renderExpirationTime</span><span class="token operator">:</span> ExpirationTime <span class="token comment">// 优先级相关</span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Fiber</span><span class="token template-punctuation string">`</span></span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...省略函数体</span>
<span class="token punctuation">}</span>

</code></pre></div><p>该方法会根据传入的 <code>Fiber</code> 节点创建子 <code>Fiber</code> 节点,并将这两个 <code>Fiber</code> 节点连接起来。</p> <p>当遍历到叶子节点（即没有子组件的组件）时就会进入&quot;归&quot;阶段。</p> <p><strong>&quot;归阶段&quot;</strong></p> <p>在&quot;归&quot;阶段会调用<code>completeWork</code>处理 <code>Fiber</code> 节点。</p> <blockquote><p>completeWork 将根据 workInProgress 节点的 tag 属性的不同,进入不同的 DOM 节点的创建、处理逻辑。</p></blockquote> <p>completeWork 内部有 3 个关键动作：</p> <ul><li>创建 DOM 节点（CreateInstance）</li> <li>将 DOM 节点插入到 DOM 树中（AppendAllChildren）</li> <li>为 DOM 节点设置属性（FinalizeInitialChildren）</li></ul> <p>当某个 <code>Fiber</code> 节点执行完<code>completeWork</code>,如果其存在兄弟 <code>Fiber</code> 节点（即<code>fiber.sibling !== null</code>）,会进入其兄弟 <code>Fiber</code> 的&quot;递&quot;阶段。</p> <p>如果不存在兄弟 Fiber,会进入父级 <code>Fiber</code> 的&quot;归&quot;阶段。</p> <p>&quot;递&quot;和&quot;归&quot;阶段会交错执行直到&quot;归&quot;到 rootFiber。至此,协调阶段的工作就结束了。</p> <h3 id="commit-提交阶段"><a href="#commit-提交阶段" class="header-anchor">#</a> commit 提交阶段</h3> <p>commit 阶段的主要工作（即 Renderer 的工作流程）分为三部分：</p> <ul><li>before mutation 阶段,这个阶段 DOM 节点还没有被渲染到界面上去,过程中会触发 <code>getSnapshotBeforeUpdate</code>,也会处理 <code>useEffect</code> 钩子相关的调度逻辑。</li> <li>mutation 阶段,这个阶段负责 DOM 节点的渲染。在渲染过程中,会遍历 effectList,根据 flags（effectTag）的不同,执行不同的 DOM 操作。</li> <li>layout 阶段,这个阶段处理 DOM 渲染完毕之后的收尾逻辑。比如调用 <code>componentDidMount/componentDidUpdate</code>,调用 <code>useLayoutEffect</code> 钩子函数的回调等。除了这些之外,它还会把 fiberRoot 的 current 指针指向 workInProgress <code>Fiber</code> 树。</li></ul> <h2 id="fiber-tree-与-workinprogress-tree"><a href="#fiber-tree-与-workinprogress-tree" class="header-anchor">#</a> Fiber tree 与 workInProgress tree</h2> <p>双缓冲技术（double buffering），就像<a href="http://www.ayqy.net/blog/redux%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/#articleHeader7" target="_blank" rel="noopener noreferrer">redux 里的<code>nextListeners</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，以 fiber tree 为主，workInProgress tree 为辅</p> <p>双缓冲具体指的是<code>workInProgress tree</code>构造完毕，得到的就是新的<code>fiber tree</code>，然后喜新厌旧（把 current 指针指向 workInProgress tree，丢掉旧的 fiber tree）就好了</p> <p>这样做的好处：</p> <ul><li><p>能够复用内部对象（fiber）</p></li> <li><p>节省内存分配、GC 的时间开销</p></li></ul> <p>每个 fiber 上都有个<code>alternate</code>属性，也指向一个 fiber，创建 <code>workInProgress</code> 节点时优先取<code>alternate</code>，没有的话就创建一个：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> workInProgress <span class="token operator">=</span> current<span class="token punctuation">.</span>alternate<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//...这里很有意思</span>
  workInProgress<span class="token punctuation">.</span>alternate <span class="token operator">=</span> current<span class="token punctuation">;</span>
  current<span class="token punctuation">.</span>alternate <span class="token operator">=</span> workInProgress<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// We already have an alternate.</span>
  <span class="token comment">// Reset the effect tag.</span>
  workInProgress<span class="token punctuation">.</span>effectTag <span class="token operator">=</span> NoEffect<span class="token punctuation">;</span>

  <span class="token comment">// The effect list is no longer valid.</span>
  workInProgress<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  workInProgress<span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  workInProgress<span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如注释指出的，fiber 与 workInProgress 互相持有引用，“喜新厌旧”之后，旧 fiber 就作为新 fiber 更新的<em>预留空间</em>，达到复用 fiber 实例的目的</p> <p>P.S.源码里还有一些有意思的技巧，比如<a href="http://makersden.io/blog/look-inside-fiber/#side-effect-tags-types-of-side-effects" target="_blank" rel="noopener noreferrer">tag 的位运算<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="优先级策略"><a href="#优先级策略" class="header-anchor">#</a> 优先级策略</h2> <p>每个工作单元运行时有 6 种优先级：</p> <ul><li><p>synchronous 与之前的 Stack reconciler 操作一样，同步执行</p></li> <li><p>task 在 next tick 之前执行</p></li> <li><p>animation 下一帧之前执行</p></li> <li><p>high 在不久的将来立即执行</p></li> <li><p>low 稍微延迟（<code>100-200ms</code>）执行也没关系</p></li> <li><p>offscreen 下一次 render 时或 scroll 时才执行</p></li></ul> <p>synchronous 首屏（首次渲染）用，要求尽量快，不管会不会阻塞 UI 线程。<strong>animation 通过<code>requestAnimationFrame</code>来调度</strong>，这样在下一帧就能立即开始动画过程；后 3 个都是由<code>requestIdleCallback</code>回调执行的；offscreen 指的是当前隐藏的、屏幕外的（看不见的）元素</p> <p>高优先级的比如键盘输入（希望立即得到反馈），低优先级的比如网络请求，让评论显示出来等等。另外，<em>紧急的事件允许插队</em></p> <p>这样的优先级机制存在<em>2 个问题</em>：</p> <ul><li><p>生命周期函数怎么执行（可能被频频中断）：触发顺序、次数没有保证了</p></li> <li><p>starvation（低优先级饿死）：如果高优先级任务很多，那么低优先级任务根本没机会执行（就饿死了）</p></li></ul> <p>生命周期函数的问题有一个官方例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>low <span class="token constant">A</span>
<span class="token function">componentWillUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">-</span>
high <span class="token constant">B</span>
<span class="token function">componentWillUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">--</span><span class="token operator">-</span>
restart low <span class="token constant">A</span>
<span class="token function">componentWillUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div><p>第 1 个问题正在解决（还没解决），生命周期的问题会破坏一些现有 App，给平滑升级带来困难，Fiber 团队正在努力寻找优雅的升级途径</p> <p>第 2 个问题通过尽量复用已完成的操作（reusing work where it can）来缓解，听起来也是正在想办法解决</p> <p>这两个问题本身不太好解决，只是解决到什么程度的问题。比如第一个问题，如果组件生命周期函数掺杂副作用太多，就没有办法无伤解决。这些问题虽然会给升级 Fiber 带来一定阻力，但绝不是不可解的（退一步讲，如果新特性有足够的吸引力，第一个问题大家自己想办法就解决了）</p> <h2 id="fiber-reconciliation-阶段中的-diff-算法"><a href="#fiber-reconciliation-阶段中的-diff-算法" class="header-anchor">#</a> <code>Fiber</code> reconciliation 阶段中的 diff 算法</h2> <p>React16 的 diff 策略采用从链表头部开始比较的算法，是<strong>层次遍历</strong>，算法是建立在一个节点的插入、删除、移动等操作都是在节点树的<strong>同一层级</strong>中进行的。</p> <p>对于 Diff， 新老节点的对比，我们以新节点为标准，然后来构建整个<code>currentInWorkProgress</code>，对于新的 children 会有四种情况:</p> <ul><li>TextNode(包含字符串和数字)</li> <li>单个 React Element(通过该节点是否有 <code>$$typeof</code> 区分)</li> <li>数组</li> <li>可迭代的 children，跟数组的处理方式差不多</li></ul> <h3 id="代码部分"><a href="#代码部分" class="header-anchor">#</a> 代码部分</h3> <p><code>reconcileChildFibers</code> 就是 Diff 部分的主体代码，这个函数超级长，是一个包装函数，下面所有的 diff 代码都在这里面;</p> <p><strong>参数介绍</strong></p> <ul><li><code>returnFiber</code> 是即将 Diff 的这层的父节点。</li> <li><code>currentFirstChild</code>是当前层的第一个 Fiber 节点。</li> <li><code>newChild</code> 是即将更新的 vdom 节点(可能是 TextNode、可能是 ReactElement，可能是数组)，不是 Fiber 节点</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reconcileChildFibers</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">returnFiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">currentFirstChild</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">newChild</span><span class="token operator">:</span> any<span class="token punctuation">,</span>
  <span class="token literal-property property">lanes</span><span class="token operator">:</span> Lanes</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> isUnkeyedTopLevelFragment <span class="token operator">=</span>
    <span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">&amp;&amp;</span>
    newChild <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
    newChild<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token constant">REACT_FRAGMENT_TYPE</span> <span class="token operator">&amp;&amp;</span>
    newChild<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isUnkeyedTopLevelFragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    newChild <span class="token operator">=</span> newChild<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Handle object types</span>
  <span class="token keyword">const</span> isObject <span class="token operator">=</span> <span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">&amp;&amp;</span> newChild <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>isObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略，此处为React Elementlei'x</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果是文本类型的则进行文本节点的diff</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> newChild <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">placeSingleChild</span><span class="token punctuation">(</span>
      <span class="token function">reconcileSingleTextNode</span><span class="token punctuation">(</span>
        returnFiber<span class="token punctuation">,</span>
        currentFirstChild<span class="token punctuation">,</span>
        <span class="token string">&quot;&quot;</span> <span class="token operator">+</span> newChild<span class="token punctuation">,</span>
        lanes
      <span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如 果是十足类型的</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isArray</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reconcileChildrenArray</span><span class="token punctuation">(</span>
      returnFiber<span class="token punctuation">,</span>
      currentFirstChild<span class="token punctuation">,</span>
      newChild<span class="token punctuation">,</span>
      lanes
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getIteratorFn</span><span class="token punctuation">(</span>newChild<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reconcileChildrenIterator</span><span class="token punctuation">(</span>
      returnFiber<span class="token punctuation">,</span>
      currentFirstChild<span class="token punctuation">,</span>
      newChild<span class="token punctuation">,</span>
      lanes
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 更新删除掉了所有节点，执行删除</span>
  <span class="token keyword">return</span> <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="针对文本节点"><a href="#针对文本节点" class="header-anchor">#</a> 针对文本节点</h4> <ol><li><p><strong>第一种情况。xxx 是一个 TextNode，那么就代表这这个节点可以复用，有复用的节点，对性能优化很有帮助</strong>。既然新的 child 只有一个 TextNode，那么复用节点之后，就把剩下的 节点就可以删掉了，那么 div 的 child 就可以添加到 workInProgress 中去了;</p></li> <li><p>第二种情况。当前节点 不是一个 TextNode，那么就代表这个节点不能复用，所以就从 currentFirstChild 开始删掉剩余的节点;</p></li></ol> <blockquote><p>注意：删除节点不会真的从链表里面把节点删除，只是打一个 delete 的 tag，当 commit 的时候才会真正的去删除。</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reconcileSingleTextNode</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span></span><span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token punctuation">{</span>
  <span class="token comment">//旧的节点也是一个 text节点 则可以复用</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentFirstChild <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> currentFirstChild<span class="token punctuation">.</span>tag <span class="token operator">===</span> HostText<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//删除兄弟</span>
    <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//复用</span>
    <span class="token keyword">const</span> existing <span class="token operator">=</span> <span class="token function">useFiber</span><span class="token punctuation">(</span>currentFirstChild<span class="token punctuation">,</span> textContent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    existing<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
    <span class="token keyword">return</span> existing<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 否则创建新的fiber节点，将旧的节点和旧节点的兄弟都删除</span>
  <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> created <span class="token operator">=</span> <span class="token function">createFiberFromText</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  created<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
  <span class="token keyword">return</span> created<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h4 id="针对-react-element"><a href="#针对-react-element" class="header-anchor">#</a> 针对 React Element</h4> <p>**如何判断这个节点是否可以复用呢？**从哪个下面的代码可以看出:</p> <ol><li>key 相同。</li> <li>节点的类型相同。</li></ol> <p>如果以上两点相同，就代表这个节点只是变化了内容，不需要创建新的节点，可以复用的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reconcileSingleElement</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">returnFiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">currentFirstChild</span><span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token literal-property property">element</span><span class="token operator">:</span> ReactElement<span class="token punctuation">,</span>
  <span class="token literal-property property">lanes</span><span class="token operator">:</span> Lanes</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Fiber <span class="token punctuation">{</span>
  <span class="token keyword">const</span> key <span class="token operator">=</span> element<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
  <span class="token keyword">let</span> child <span class="token operator">=</span> currentFirstChild<span class="token punctuation">;</span>
  <span class="token comment">//初始渲染这个currentFirstChild直接传的null，所以更新时候才会diff</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>child <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// TODO: If key === null and child.key === null, then this only applies to</span>
    <span class="token comment">// the first item in the list.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>key <span class="token operator">===</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> elementType <span class="token operator">=</span> element<span class="token punctuation">.</span>type<span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>elementType <span class="token operator">===</span> <span class="token constant">REACT_FRAGMENT_TYPE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>tag <span class="token operator">===</span> Fragment<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 相同的老的节点的兄弟节点清空  为了本次可以复用</span>
          <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// 如果是fragment复用的是children,对于 Fragment 节点和一般的 Element 节点创建的方式不同，因为 Fragment 本来就是一个无意义的节点，他真正需要创建 Fiber 的是它的 children，而不是它自己</span>
          <span class="token keyword">const</span> existing <span class="token operator">=</span> <span class="token function">useFiber</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> element<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">;</span>
          existing<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
          <span class="token keyword">return</span> existing<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果类型相同</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>
          child<span class="token punctuation">.</span>elementType <span class="token operator">===</span> elementType <span class="token operator">||</span>
          <span class="token boolean">false</span> <span class="token operator">||</span>
          <span class="token punctuation">(</span>enableLazyElements <span class="token operator">&amp;&amp;</span>
            <span class="token keyword">typeof</span> elementType <span class="token operator">===</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">&amp;&amp;</span>
            elementType <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
            elementType<span class="token punctuation">.</span>$$<span class="token keyword">typeof</span> <span class="token operator">===</span> <span class="token constant">REACT_LAZY_TYPE</span> <span class="token operator">&amp;&amp;</span>
            <span class="token function">resolveLazy</span><span class="token punctuation">(</span>elementType<span class="token punctuation">)</span> <span class="token operator">===</span> child<span class="token punctuation">.</span>type<span class="token punctuation">)</span>
        <span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 相同的老的节点的兄弟节点清空  为了本次可以复用</span>
          <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">const</span> existing <span class="token operator">=</span> <span class="token function">useFiber</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> element<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
          existing<span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token function">coerceRef</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
          existing<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
          <span class="token keyword">return</span> existing<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// key相同但是节点类型不同，无法复用并且兄弟节点也不可复用，全部删除</span>
      <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// key都不相同 则无法服用，但是其兄弟可能还会复用上次的</span>
      <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//既然是单个节点的调和  为何还用while遍历所有兄弟节点呢？</span>
    <span class="token comment">/**
     * old: a b
     * new: b
     * 如果老节点存在兄弟节点（老节点和新节点不一致），刚好和现在的节点类型一致，这样也可复用
     */</span>
    child <span class="token operator">=</span> child<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//上面如果执行完没有可复用的 则进入这里进行创建,对于 Fragment 节点和一般的 Element 节点创建的方式不同，因为 Fragment 本来就是一个无意义的节点，他真正需要创建 Fiber 的是它的 children，而不是它自己，所以 createFiberFromFragment 传递的不是 element，而是 element.props.children</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token constant">REACT_FRAGMENT_TYPE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> created <span class="token operator">=</span> <span class="token function">createFiberFromFragment</span><span class="token punctuation">(</span>
      element<span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">,</span>
      returnFiber<span class="token punctuation">.</span>mode<span class="token punctuation">,</span>
      lanes<span class="token punctuation">,</span>
      element<span class="token punctuation">.</span>key
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    created<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
    <span class="token keyword">return</span> created<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> created <span class="token operator">=</span> <span class="token function">createFiberFromElement</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> returnFiber<span class="token punctuation">.</span>mode<span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    created<span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token function">coerceRef</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> currentFirstChild<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    created<span class="token punctuation">.</span>return <span class="token operator">=</span> returnFiber<span class="token punctuation">;</span>
    <span class="token keyword">return</span> created<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>单个节点的复用逻辑比较清晰，初次渲染直接 <code>created</code>，<strong>更新时判断 <code>key</code> 是否一致，再判断节点类型是否一致，如果条件满足则复用旧的节点</strong>。不满足时稍微复杂一些，有如下三个注意点：</p> <ul><li><strong>key 相同但 type 不同</strong>代表更新的单个节点和旧的节点（以及旧节点的兄弟节点）肯定无法复用了，所以执行的方式是删除旧的和兄弟节点(<code>deleteRemainingChildren</code>)。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">old</span><span class="token operator">:</span>    div <span class="token operator">&gt;</span> p p p
<span class="token keyword">new</span><span class="token operator">:</span>    div <span class="token operator">&gt;</span> span

</code></pre></div><ul><li><strong>key 不同</strong> :代表更新的单个节点和旧的某个节点无法复用，但是有可能旧的兄弟节点可被复用，所以执行的方式是只删除旧的节点(<code>deleteChild</code>)。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">old</span><span class="token operator">:</span> p1  p2  p3
<span class="token keyword">new</span><span class="token operator">:</span> p2

</code></pre></div><ul><li><strong>while 循环</strong>: 通过上面整个例子可以知道为何单个节点还要遍历，这就是 <code>react</code> 的一种优化措施，<code>key</code> 不同，但是有可能兄弟节点还是可复用的，所以继续 <code>child.sibling</code></li></ul> <h4 id="diff-array-的比较"><a href="#diff-array-的比较" class="header-anchor">#</a> Diff Array 的比较</h4> <p><img src="https://ask.qcloudimg.com/http-save/yehe-1210525/wuayf36g9t.jpeg?imageView2/2/w/1620" alt=""></p> <p><strong>1. 第一次循环: 相同位置(index)进行比较</strong></p> <p>这是第一次遍历新数组，通过调用 <code>updateSlot</code> 来对比新老元素，对比新老节点的代码都是在这个函数里。这个循环会把所有的从前面开始能复用的节点，都复用到。比如上面我们画的图，如果两个链表里面的 **？？？**节点，不相同，那么 newFiber 为 null，这个循环就会跳出。</p> <p>跳出来了，就会有两种情况。</p> <ul><li>新节点已经遍历完毕</li> <li>老节点已经遍历完毕</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 第一次遍历的代码:</span>


<span class="token comment">//第一次遍历  同位置的比较</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> oldFiber <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber<span class="token punctuation">.</span>index <span class="token operator">&gt;</span> newIdx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// oldFiber在本循环的最下面会被赋值为 nextOldFiber，不断的寻找兄弟节点</span>
    <span class="token comment">//[null, a] =&gt; [b, a]</span>
    nextOldFiber <span class="token operator">=</span> oldFiber<span class="token punctuation">;</span>
    oldFiber <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">//正常的情况下 为了下轮循环，拿到兄弟节点下面赋值给oldFiber</span>
    nextOldFiber <span class="token operator">=</span> oldFiber<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//这里面根据key 判断是否可以复用节点（准确的说，有可能节点类型会不同，其他属性和值相同）</span>
  <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">updateSlot</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//节点无法复用 跳出循环 下方详解</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oldFiber <span class="token operator">=</span> nextOldFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//更新</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">&amp;&amp;</span> newFiber<span class="token punctuation">.</span>alternate <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//删除，下方详解</span>
      <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//本次遍历会给新增的节点打 插入的标记</span>
  lastPlacedIndex <span class="token operator">=</span> <span class="token function">placeChild</span><span class="token punctuation">(</span>newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">...</span>
  <span class="token comment">//重新给 oldFiber 赋值继续遍历</span>
  oldFiber <span class="token operator">=</span> nextOldFiber<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


</code></pre></div><p><strong>2. 新节点已经遍历完毕(节点删除情况)</strong></p> <p>如果新节点已经遍历完毕的话，也就是没有要更新的了，这种情况一般就是从原来的数组里面删除了元素，那么直接把剩下的老节点删除了就行了。还是拿上面的图的例子举例，老的链表里？？？还有很多节点，而新的链表？？？已经没有节点了，所以老的链表？？？不管是有多少节点，都不能复用了，所以没用了，直接删除。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>newIdx <span class="token operator">===</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 新的 children 长度已经够了，所以把剩下的删除掉</span>
  <span class="token function">deleteRemainingChildren</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意这里是直接 <code>return</code> 了哦，没有继续往下执行了。</p> <p><strong>3. 老节点已经遍历完毕(节点新增情况)</strong></p> <p>如果老的节点在第一次循环的时候就被复用完了，新的节点还有，很有可能就是新增了节点的情况。那么这个时候只需要根据把剩余新的节点直接创建 <strong>Fiber</strong> 就行了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果老的节点已经被复用完了，对剩下的新节点进行操作</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">createChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> newChildren<span class="token punctuation">[</span>newIdx<span class="token punctuation">]</span><span class="token punctuation">,</span> lanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>oldFiber === null</code> 就是用来判断老的 Fiber 节点变量完了的代码，Fiber 链表是一个单向链表，所以为 null 的时候代表已经结束了。所以就直接把剩余的 newChild 通过循环创建 Fiber。</p> <p>到这里，目前简单的对数组进行增、删节点的对比还是比较简单，接下来就是移动的情况是如何进行复用的呢</p> <p><strong>4. 移动的情况如何进行节点复用(节点修改)</strong></p> <p>对于移动的情况，首先要思考，怎么能判断数组是否发生过移动操作呢？</p> <p>如果给你两个数组，你是否能判断出来数组是否发生过移动。</p> <p>答案是：老的数组和新的数组里面都有这个元素，而且位置不相同。</p> <p>从两个数组中找到相同元素(是指可复用的节点)，方法有很多种，来看看 React 是如何高效的找出来的。</p> <p><strong>把所有老数组元素按 key 或者是 index 放 Map 里，然后遍历新数组，根据新数组的 key 或者 index 看看是否存在相同的 key 或者 index 标识的旧节点</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mapRemainingChildren</span><span class="token punctuation">(</span>
  <span class="token parameter"><span class="token literal-property property">returnFiber</span><span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  <span class="token literal-property property">currentFirstChild</span><span class="token operator">:</span> Fiber</span>
<span class="token punctuation">)</span><span class="token operator">:</span> Map<span class="token operator">&lt;</span>string <span class="token operator">|</span> number<span class="token punctuation">,</span> Fiber<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token literal-property property">existingChildren</span><span class="token operator">:</span> Map<span class="token operator">&lt;</span>string <span class="token operator">|</span> number<span class="token punctuation">,</span> Fiber<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> existingChild <span class="token operator">=</span> currentFirstChild<span class="token punctuation">;</span> <span class="token comment">// currentFirstChild 是老数组链表的第一个元素</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>existingChild <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 看到这里可能会疑惑怎么在 Map 里面的key 是 fiber 的key 还是 fiber 的 index 呢？</span>
    <span class="token comment">// 我觉得是根据数据类型，fiber 的key 是字符串，而 index 是数字，这样就能区分了</span>
    <span class="token comment">// 所以这里是用的 map，而不是对象，如果是对象的key 就不能区分 字符串类型和数字类型了。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>existingChild<span class="token punctuation">.</span>key <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      existingChildren<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>existingChild<span class="token punctuation">.</span>key<span class="token punctuation">,</span> existingChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      existingChildren<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>existingChild<span class="token punctuation">.</span>index<span class="token punctuation">,</span> existingChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 兄弟节点挨个遍历</span>
    existingChild <span class="token operator">=</span> existingChild<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> existingChildren<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个 <code>mapRemainingChildren</code> 就是将老数组存放到 Map 里面。元素有 key 就 Map 的键就存 key，没有 key 就存 index，key 一定是字符串，index 一定是 number，所以取的时候是能区分的，所以这里用的是 Map，而不是对象，如果是对象，属性是字符串，就没办法区别是 key 还是 index 了。</p> <p>现在有了这个 Map，剩下的就是循环新数组，找到 Map 里面可以复用的节点，如果找不到就创建，这个逻辑基本上跟 <code>updateSlot</code> 的复用逻辑很像，一个是从老数组链表中获取节点对比，一个是从 Map 里获取节点对比。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 如果前面的算法有复用，那么 newIdx 就不从 0 开始</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> newIdx <span class="token operator">&lt;</span> newChildren<span class="token punctuation">.</span>length<span class="token punctuation">;</span> newIdx<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> newFiber <span class="token operator">=</span> <span class="token function">updateFromMap</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里正常情况下会返回值  复用或新创建 和updateSlot不同</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newFiber<span class="token punctuation">.</span>alternate <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 新的节点是复用老节点  从Map对象中删除旧节点值</span>
        existingChildren<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>
          newFiber<span class="token punctuation">.</span>key <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> newIdx <span class="token operator">:</span> newFiber<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 更新index 判定哪些节点需要被标记 插入effectTag</span>
    lastPlacedIndex <span class="token operator">=</span> <span class="token function">placeChild</span><span class="token punctuation">(</span>newFiber<span class="token punctuation">,</span> lastPlacedIndex<span class="token punctuation">,</span> newIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>previousNewFiber <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//返回时候只需要返回自己   因为兄弟节点都挂载到自己身上了</span>
      resultingFirstChild <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">//不停的给自己追加兄弟 a---&gt;b---&gt;c---&gt;d</span>
      previousNewFiber<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    previousNewFiber <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>shouldTrackSideEffects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//旧节点中还存在，没法被复用  这里需要遍历删除</span>
  existingChildren<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> <span class="token function">deleteChild</span><span class="token punctuation">(</span>returnFiber<span class="token punctuation">,</span> child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 只需要返回第一个节点即可   后面兄弟通过 slibling连接</span>
<span class="token keyword">return</span> resultingFirstChild<span class="token punctuation">;</span>

</code></pre></div><p>到这里新数组遍历完毕，也就是<strong>同一层</strong>的 Diff 过程完毕，接下来进行总结一下:</p> <p>对于数组的 diff 策略，相对比较复杂，最后来梳理一下这个策略，其实还是很简单，只是看源码的时候比较难懂。</p> <p>我们可以把整个过程分为三个阶段：</p> <ol><li>第一遍历新数组，新老数组相同 index 进行对比，通过 <code>updateSlot</code>方法找到可以复用的节点，直到找到不可以复用的节点就退出循环。</li> <li>第一遍历完之后，删除剩余的老节点，追加剩余的新节点的过程: <strong>如果是新节点已遍历完成，就将剩余的老节点批量删除；如果是老节点遍历完成仍有新节点剩余，则将新节点直接插入</strong>。如果有删除/新增则直接返回，不进行下一个步骤.</li> <li>(非新增/删除的情况)即移动的情况: 把所有老数组元素按 key 或 index 放 Map 里，然后遍历新数组，插入老数组的元素，这是移动的情况。</li></ol> <h3 id="diff-总结"><a href="#diff-总结" class="header-anchor">#</a> diff 总结</h3> <ol><li><strong>针对文本节点</strong></li></ol> <ul><li><p><strong>第一种情况。旧节点是一个 TextNode，那么就代表这这个节点可以复用，有复用的节点，对性能优化很有帮助</strong>。既然新的 child 只有一个 TextNode，那么复用节点之后，就把剩下的 节点就可以删掉了，那么 div 的 child 就可以添加到 workInProgress 中去了;</p></li> <li><p>第二种情况: 旧节点 不是一个 TextNode，那么就代表这个节点不能复用，所以就从 currentFirstChild 开始删掉剩余的节点;</p></li></ul> <ol start="2"><li><strong>针对 React 节点</strong></li></ol> <ul><li><p>初次渲染直接 <code>created</code>，<strong>更新时判断 <code>key</code> 是否一致，再判断节点类型是否一致，如果条件满足则复用旧的节点</strong>。不满足时稍微复杂一些;</p></li> <li><p><strong>key 相同但 type 不同</strong>代表更新的单个节点和旧的节点（以及旧节点的兄弟节点）肯定无法复用了，所以执行的方式是删除旧的和兄弟节点(<code>deleteRemainingChildren</code>)。</p></li> <li><p><strong>key 不同</strong> :代表更新的单个节点和旧的某个节点无法复用，但是有可能旧的兄弟节点可被复用，所以执行的方式是只删除旧的节点(<code>deleteChild</code>)。</p></li> <li><p><strong>while 循环</strong>: 查看兄弟节点是否可以复用;</p></li></ul> <ol start="3"><li><strong>针对列表</strong></li></ol> <ul><li>第一遍历新数组，新老数组相同 index 进行对比，通过 <code>updateSlot</code>方法找到可以复用的节点，直到找到不可以复用的节点就退出循环。</li> <li>第一遍历完之后，删除剩余的老节点，追加剩余的新节点的过程: <strong>如果是新节点已遍历完成，就将剩余的老节点批量删除；如果是老节点遍历完成仍有新节点剩余，则将新节点直接插入</strong>。如果有删除/新增则直接返回，不进行下一个步骤.</li> <li>(非新增/删除的情况)即移动的情况: 把所有老数组元素按 key 或 index 放 Map 里，然后遍历新数组，插入老数组的元素，这是移动的情况。</li></ul> <h2 id="fiber总结"><a href="#fiber总结" class="header-anchor">#</a> <code>Fiber</code>总结</h2> <h3 id="如何解决主线程长时间占用问题"><a href="#如何解决主线程长时间占用问题" class="header-anchor">#</a> 如何解决主线程长时间占用问题?</h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>问题描述:
React 在一些响应体验要求较高的场景不适用，比如动画，布局和手势;根本原因是渲染/更新过程一旦开始无法中断，持续占用主线程，主线程忙于执行 JS，无暇他顾（布局、动画），造成掉帧、延迟响应（甚至无响应）等不佳体验</p></div> <p>求: 一种能够彻底解决主线程长时间占用问题的机制，不仅能够应对眼前的问题，还要有长远意义</p> <blockquote><p>The “fiber” reconciler is a new effort aiming to resolve the problems inherent in the stack reconciler and fix a few long-standing issues.</p></blockquote> <p><strong>解决方案</strong></p> <p><strong>把渲染/更新过程拆分为小块任务，通过合理的调度机制来控制时间（更细粒度、更强的控制力）</strong></p> <p>那么，面临 5 个子问题：</p> <h3 id="_1-拆什么-什么不能拆"><a href="#_1-拆什么-什么不能拆" class="header-anchor">#</a> 1. 拆什么？什么不能拆？</h3> <p>把渲染/更新过程分为 2 个阶段（diff + patch）：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span><span class="token punctuation">.</span>diff <span class="token operator">~</span> render<span class="token operator">/</span>reconciliation
<span class="token number">2</span><span class="token punctuation">.</span>patch <span class="token operator">~</span> commit

</code></pre></div><p><code>diff</code> 的实际工作是对比<code>prevInstance</code>和<code>nextInstance</code>的状态，找出差异及其对应的 DOM change。diff 本质上是一些计算（遍历、比较），是可拆分的（算一半待会儿接着算）</p> <p><code>patch</code> 阶段把本次更新中的所有 <code>DOM change</code> 应用到 DOM 树，是一连串的 DOM 操作。这些 DOM 操作虽然看起来也可以拆分（按照 change list 一段一段做），但这样做一方面可能造成 DOM 实际状态与维护的内部状态不一致，另外还会影响体验。而且，一般场景下，DOM 更新的耗时比起 diff 及生命周期函数耗时不算什么，拆分的意义不很大</p> <p>所以，<strong><code>render/reconciliation</code> <code>阶段的工作（diff）可以拆分，commit</code> 阶段的工作（patch）不可拆分</strong></p> <p><strong>P.S.</strong> diff 与 reconciliation 只是对应关系，并不等价，如果非要区分的话，reconciliation 包括 diff：</p> <blockquote><p>This is a part of the process that React calls reconciliation which starts when you call ReactDOM.render() or setState(). By the end of the reconciliation, React knows the result DOM tree, and a renderer like react-dom or react-native applies the minimal set of changes necessary to update the DOM nodes (or the platform-specific views in case of React Native).</p></blockquote> <p>（引自<a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html#top-down-reconciliation" target="_blank" rel="noopener noreferrer">Top-Down Reconciliation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）</p> <h3 id="_2-怎么拆"><a href="#_2-怎么拆" class="header-anchor">#</a> 2. 怎么拆？</h3> <p>先凭空乱来几种 diff 工作拆分方案：</p> <ul><li><p>按组件结构拆。不好分，无法预估各组件更新的工作量</p></li> <li><p>按实际工序拆。比如分为<code>getNextState(), shouldUpdate(), updateState(), checkChildren()</code>再穿插一些生命周期函数</p></li></ul> <p>按组件拆太粗，显然对大组件不太公平。按工序拆太细，任务太多，频繁调度不划算。那么有没有合适的拆分单位？</p> <p>有。Fiber 的拆分单位是 fiber（fiber tree 上的一个节点），实际上就是<em>按虚拟 DOM 节点拆</em>，因为 fiber tree 是根据 vDOM tree 构造出来的，树结构一模一样，只是节点携带的信息有差异</p> <p>所以，实际上是 vDOM node 粒度的拆分（以 fiber 为工作单元），每个组件实例和每个 DOM 节点抽象表示的实例都是一个工作单元。工作循环中，每次处理一个 fiber，处理完可以中断/挂起整个工作循环</p> <h3 id="_3-如何调度任务"><a href="#_3-如何调度任务" class="header-anchor">#</a> 3. 如何调度任务？</h3> <p>分 2 部分：</p> <ul><li><strong>工作循环</strong></li> <li><strong>优先级机制</strong></li></ul> <p>工作循环是<em>基本的任务调度机制</em>，工作循环中每次处理一个任务（工作单元），处理完毕有一次喘息的机会：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Flush asynchronous work until the deadline runs out of time.</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>nextUnitOfWork <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  nextUnitOfWork <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>nextUnitOfWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>shouldYield</code>就是看时间用完了没（<code>idleDeadline.timeRemaining()</code>），没用完的话继续处理下一个任务，用完了就结束，把时间控制权还给主线程，等下一次<code>requestIdleCallback</code>回调再接着做：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// If there's work left over, schedule a new callback.</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>nextFlushedExpirationTime <span class="token operator">!==</span> NoWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">scheduleCallbackWithExpiration</span><span class="token punctuation">(</span>nextFlushedExpirationTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也就是说，（不考虑突发事件的）正常调度是由工作循环来完成的，基本<em>规则</em>是：<strong>每个工作单元结束检查是否还有时间做下一个，没时间了就先“挂起”</strong></p> <p>优先级机制用来处理突发事件与优化次序，例如：</p> <ul><li><p>到 commit 阶段了，提高优先级</p></li> <li><p>高优任务做一半出错了，给降一下优先级</p></li> <li><p>抽空关注一下低优任务，别给饿死了</p></li> <li><p>如果对应 DOM 节点此刻不可见，给降到最低优先级</p></li></ul> <p>这些策略用来动态调整任务调度，是工作循环的<em>辅助机制</em>，最先做最重要的事情</p> <h3 id="_4-如何中断-断点恢复"><a href="#_4-如何中断-断点恢复" class="header-anchor">#</a> 4. 如何中断/断点恢复？</h3> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>中断：检查当前正在处理的工作单元，保存当前成果（<code>firstEffect, lastEffect</code>），修改 tag 标记一下，迅速收尾并再开一个<code>requestIdleCallback</code>，下次有机会再做;</p></div> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>断点恢复：下次再处理到该工作单元时，看 tag 是被打断的任务，接着做未完成的部分或者重做</p></div> <p>P.S.无论是时间用尽“自然”中断，还是被高优任务粗暴打断，对中断机制来说都一样</p> <h3 id="_5-如何收集任务结果"><a href="#_5-如何收集任务结果" class="header-anchor">#</a> 5. 如何收集任务结果？</h3> <p>Fiber <code>reconciliation</code> 的工作循环具体如下：</p> <ol><li><p>找到根节点优先级最高的 <code>workInProgress tree</code>，取其待处理的节点（代表组件或 DOM 节点）</p></li> <li><p>检查当前节点<em>是否需要更新</em>，不需要的话，直接到 4</p></li> <li><p>标记一下（打个 tag），更新自己（组件更新<code>props</code>，<code>context</code>等，DOM 节点记下 DOM change），并为孩子生成 <code>workInProgress node</code></p></li> <li><p>如果没有产生子节点，归并 <code>effect list</code>（包含 DOM change）到父级</p></li> <li><p>把孩子或兄弟作为待处理节点，准备进入下一个工作循环。如果没有待处理节点（回到了 workInProgress tree 的根节点），工作循环结束</p></li></ol> <p>通过每个节点更新结束时<em>向上归并 effect list</em><code>来收集任务结果，reconciliation</code> 结束后，根节点的 <code>effect list</code>里记录了包括 <code>DOM change</code> 在内的所有 <code>side effect</code></p> <h3 id="举一反三"><a href="#举一反三" class="header-anchor">#</a> 举一反三</h3> <p>既然任务可拆分（只要最终得到完整 effect list 就行），那就允许<em>并行执行</em>（多个 Fiber reconciler + 多个 worker），首屏也更容易分块加载/渲染（vDOM 森林）</p> <p>并行渲染的话，据说 Firefox 测试结果显示，130ms 的页面，只需要 30ms 就能搞定，所以在这方面是值得期待的，而 React 已经做好准备了，这也就是在 React Fiber 上下文经常听到的待<em>unlock</em>的更多特性之一</p> <h2 id="源码简析"><a href="#源码简析" class="header-anchor">#</a> 源码简析</h2> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <p>文章整合自:</p> <ol><li><a href="https://juejin.cn/post/6926432527980691470" target="_blank" rel="noopener noreferrer">浅谈对 React Fiber 的理解<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener noreferrer">完全理解 React Fiber<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://cloud.tencent.com/developer/article/1477707" target="_blank" rel="noopener noreferrer">详解 React 16 的 Diff 策略<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol></div> <div class="post-copyright-container"><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>
      mrgaogang.github.io
    </li> <li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://mrgaogang.github.io/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html" title="声明博客的许可协议">https://mrgaogang.github.io/react/Fiber%E7%9A%84%E7%90%86%E8%A7%A3.html</a></li> <li class="post-copyright-license"><strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用
      <a href="https://creativecommons.org/licenses/by-sa/4.0/" rel="external nofollow" target="_blank">CC BY-SA 4.0</a>
      许可协议。转载请注明出处！
    </li></ul></div> <div data-v-b4bf293e><div class="encourage" data-v-b4bf293e><button data-v-b4bf293e><span class="button-content" data-v-b4bf293e><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" data-v-b4bf293e><path d="M0 0H24V24H0z" fill="none" data-v-b4bf293e></path> <path d="M12.001 4.529c2.349-2.109 5.979-2.039 8.242.228 2.262 2.268 2.34 5.88.236 8.236l-8.48 8.492-8.478-8.492c-2.104-2.356-2.025-5.974.236-8.236 2.265-2.264 5.888-2.34 8.244-.228z" fill="currentColor" data-v-b4bf293e></path></svg>
        鼓励一下
      </span></button></div> <!----></div> <div class="divider-comment"></div> <div class="comments-wrapper"><!----></div> <footer class="page-edit"><!----> <div class="edit-link"><a target="_blank" href="https://github.com/MrGaoGang/lucky_docs/tree/master/docs/react/Fiber的理解.md">Edit This Page</a></div> <div class="last-updated"><span class="prefix">【未经作者允许禁止转载】 Last Updated: </span> <span class="time">4/13/2023, 9:18:29 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/other/谈谈为啥需要github和个人博客.html" class="prev">
          谈谈为啥需要github和个人博客
        </a></span> <span class="next"><a href="/react/Mobx异步Action方案.html">
          Mobx异步Action方案
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.818c8bb8.js" defer></script><script src="/assets/js/5.70973ade.js" defer></script><script src="/assets/js/3.ed5fe68d.js" defer></script><script src="/assets/js/196.0765e8f2.js" defer></script>
  </body>
</html>
