(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{456:function(t,a,e){"use strict";e.r(a);var r=e(1),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("内容分发网络（Content Delivery Network），是在现有 Internet 中增加的一层新的网络架构，由遍布全国的高性能加速节点构成。这些高性能的服务节点都会按照一定的缓存策略存储您的业务内容，当您的用户向您的某一业务内容发起请求时，"),e("strong",[t._v("请求会被调度至最接近用户的服务节点")]),t._v("，直接由服务节点快速响应，有效降低用户访问延迟，提升可用性.")])]),t._v(" "),e("h2",{attrs:{id:"加速原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#加速原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 加速原理")]),t._v(" "),e("p",[t._v("假设您的业务源站域名为 "),e("code",[t._v("www.test.com")]),t._v("，域名接入 CDN 开始使用加速服务后，当您的用户发起 HTTP 请求时，实际的处理流程如下图所示：\n"),e("img",{attrs:{src:"https://mc.qcloudimg.com/static/img/1bead74703061b71eeaf6bf4db27fcdb/image.png",alt:""}})]),t._v(" "),e("p",[t._v("详细说明如下：")]),t._v(" "),e("ul",[e("li",[t._v("用户向 www.test.com 下的某图片资源（如：1.jpg）发起请求，会先向 Local DNS 发起域名解析请求。")]),t._v(" "),e("li",[t._v("当 Local DNS 解析 www.test.com 时，会发现已经配置了 CNAME www.test.com.cdn.dnsv1.com，解析请求会发送至 Tencent DNS（GSLB），GSLB 为腾讯云自主研发的调度体系，会为请求分配最佳节点 IP。")]),t._v(" "),e("li",[t._v("Local DNS 获取 Tencent DNS 返回的解析 IP。")]),t._v(" "),e("li",[t._v("用户获取解析 IP。")]),t._v(" "),e("li",[t._v("用户向获取的 IP 发起对资源 1.jpg 的访问请求。")]),t._v(" "),e("li",[t._v("若该 IP 对应的节点缓存有 1.jpg，则会将数据直接返回给用户（10），此时请求结束。若该节点未缓存 1.jpg，则节点会向业务源站发起对 1.jpg 的请求（6、7、8），获取资源后，结合用户自定义配置的缓存策略（可参考产品文档中的 缓存过期配置），将资源缓存至节点（9），并返回给用户（10），此时请求结束。")])]),t._v(" "),e("h2",{attrs:{id:"缓存设置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存设置","aria-hidden":"true"}},[t._v("#")]),t._v(" 缓存设置")]),t._v(" "),e("p",[t._v("第一，缓存的设置，max-age 我们都用过，在 Cache-Control 中经常用于缓存的控制，可是 max-age 设置的缓存会应用于一个请求经过的每一级，如果我们希望 CDN 不缓存那么久，要怎么办呢？那就是 s-maxage，它用于设置代理服务器的缓存时间，会覆盖 max-age 的设置，这样我们可以把 max-age 用于本地缓存，把 s-maxage 用于 CDN 缓存时间，避免脏数据的产生。")]),t._v(" "),e("h2",{attrs:{id:"判断是否命中缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#判断是否命中缓存","aria-hidden":"true"}},[t._v("#")]),t._v(" 判断是否命中缓存")]),t._v(" "),e("p",[t._v("无论是我们自己在开发过程中，还是帮客户 debug 的过程中，我们都会考虑一件事——这个资源是否命中了CDN，是否是因为CDN导致的问题，这个时候就要秀一波操作了。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/7/20/164b5c83c50ae96f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1",alt:""}})]),t._v(" "),e("p",[t._v("在各大厂商的 CDN 返回的数据中都会有一个 X-Cache，上面内容是 Hit 或者 Miss，还会加上诸如 Memory 或者 Disk 的缩写表示内存还是磁盘，如果出现 Upstream 或者 Miss 则表示没有命中")]),t._v(" "),e("h2",{attrs:{id:"cdn预热"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cdn预热","aria-hidden":"true"}},[t._v("#")]),t._v(" CDN预热")]),t._v(" "),e("p",[t._v("我们知道将资源部署到CDN之后，当首批用户访问时并不能及时的在就近的节点上拉取对应的资源，所以通常我们需要对CDN进行预热。")]),t._v(" "),e("blockquote",[e("p",[t._v("预热功能是指提交URL预热请求后，"),e("strong",[t._v("源站将会主动将对应的资源缓存到全站加速节点，当您首次请求时，就能直接从全站加速节点缓存中获取到最新的请求资源，无需再回源站获取。预热功能会提高缓存命中率")]),t._v("。")])]),t._v(" "),e("p",[t._v("预热的操作步骤一般是在云服务厂商上面配置对应哪些url进行预热，为什么不使用目录预热呢，其主要原因是没法知道目录下面的那些资源需要预热。")]),t._v(" "),e("p",[t._v("一个例子:")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://main.qcloudimg.com/raw/d2c5486ea70edfdda3d14ca595e24392.png",alt:""}})]),t._v(" "),e("h2",{attrs:{id:"cdn刷新"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cdn刷新","aria-hidden":"true"}},[t._v("#")]),t._v(" CDN刷新")]),t._v(" "),e("p",[t._v("内容分发网络（CDN）提供基础缓存配置能力，可根据指定业务类型、目录、具体 URL 等各类规则设置缓存过期时间，来达到定期清理节点缓存资源，回源站重新拉取最新资源重新缓存的目的。")]),t._v(" "),e("p",[t._v("除此之外，CDN 提供了缓存刷新的能力，可批量指定 URL 或目录进行刷新操作：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("刷新 URL：源站有少量文件更新时，可以使用 URL 刷新 来主动删除 CDN 节点上的资源文件。新的请求进来时，CDN 节点会回源获取文件并将新的资源文件缓存至 CDN 节点，所以这是一个主动更新的过程")])]),t._v(" "),e("li",[e("p",[t._v("刷新目录：选择 “刷新变更资源” 模式，当用户访问匹配目录下资源时，会回源获取资源的 Last-Modify 信息，若与当前缓存资源一致，则直接返回已缓存资源，若不一致，回源拉取资源并重新缓存；选择 “刷新全部资源” 时，当用户访问匹配目录下资源时，直接回源拉取新资源返回给用户，并重新缓存新资源")])])]),t._v(" "),e("div",{staticClass:"tip custom-block"},[e("p",[t._v("说明：\n刷新成功执行后，节点上对应资源无有效缓存，当用户再次发起访问时，节点回源站拉取所需资源，并重新缓存在节点上。因此提交大量的刷新任务，会清空较多缓存，从而导致回源请求突增，源站会产生较大压力。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);