(window.webpackJsonp=window.webpackJsonp||[]).push([[164],{837:function(v,_,t){"use strict";t.r(_);var e=t(18),l=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),t("p",[v._v("模块化管理工具和自动化构建工具是不同的。两者主要体现在侧重点不一样。"),t("strong",[v._v("自动化构建工具")]),v._v("侧重于前端开发的  "),t("strong",[v._v("整个过程")]),v._v("  的控制管理（像是流水线）。而"),t("strong",[v._v("模块化管理工具")]),v._v("更侧重于"),t("strong",[v._v("模块打包")]),v._v("，当然我们可以把开发中的所有资源（图片、js 文件、css 文件等）都可以看成模块。")]),v._v(" "),t("ul",[t("li",[t("h2",{attrs:{id:"webpack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[v._v("#")]),v._v(" Webpack")])])]),v._v(" "),t("blockquote",[t("p",[v._v("webpack 可以说是当前最流行的"),t("strong",[v._v("模块化管理工具")]),v._v("和打包工具。其通过 loader 的转换，可以将任何形式的资源视作模块。它还可以将各个模块通过其依赖关系打包成符合生产环境部署的前端资源。它还可以将应用程序分解成可管理的代码块，可以按需加载。")])]),v._v(" "),t("p",[t("strong",[v._v("打包原理：")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fae07439b6c478f92d7033eb627c11e~tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),v._v(" "),t("p",[v._v("解析各个模块的依赖关系 使用 loader 转换文件，使用 plugin 注入钩子，打包合并模块，最终生成 bundle 文件，使用 express 开启本地服务器， 浏览器请求的是 bundle 文件，也就是打包过后的文件。")]),v._v(" "),t("p",[t("strong",[v._v("优点：")])]),v._v(" "),t("ol",[t("li",[v._v("基本之前 gulp 可以进行的操作处理，现在 webpack 也都可以做；")]),v._v(" "),t("li",[v._v("同时支持热更新，支持 tree shaking 、Scope Hoisting、动态加载、代码拆分、文件指纹、代码压缩、静态资源处理等；")]),v._v(" "),t("li",[v._v("支持多种打包方式。")])]),v._v(" "),t("p",[v._v("等等")]),v._v(" "),t("p",[t("strong",[v._v("缺点：")])]),v._v(" "),t("p",[v._v("1.各个模块之间的依赖关系过于复杂 会导致打包速度很慢")]),v._v(" "),t("p",[v._v("2.使用热更新时，改动一个模块，其他有依赖关系的模块也会重新进行打包")]),v._v(" "),t("p",[v._v("3.不支持打包出 esm 格式的代码 (打包后的代码再次被引用时 tree shaking 困难)，  打包后亢余代码较多。")]),v._v(" "),t("hr"),v._v(" "),t("ul",[t("li",[t("h2",{attrs:{id:"vite"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vite"}},[v._v("#")]),v._v(" Vite")])])]),v._v(" "),t("blockquote",[t("p",[v._v("和 webpack 差不多，vite 是当下新兴的"),t("strong",[v._v("模块化管理工具")]),v._v("和打包工具。它的本地启动速度相较于 webpack 快了很多，但是目前来说，vite 还完全没有能够替换 webpack 的能力，不管是从社区还是从能力来讲，vite 他本身还是太过脆弱，他的产生跟火热完全依赖于 vue 本身的热度。")])]),v._v(" "),t("p",[t("strong",[v._v("打包原理:")]),v._v(" "),t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/614f50eeed37481894341ade9d0802b6~tplv-k3u1fbpfcp-watermark.awebp",alt:""}})]),v._v(" "),t("p",[v._v("使用 koa 开启本地服务器，没有 webpack 那样打包合并的过程，所以启动服务器很快，"),t("code",[v._v("@vue/compiler-sfc")]),v._v(" 会对模块进行编译 （修改一些引入文件的路径 css 编译成 js 字符串）浏览器再请求编译好的模块。")]),v._v(" "),t("p",[t("strong",[v._v("缺点:")])]),v._v(" "),t("ol",[t("li",[v._v("项目的开发浏览器要支持 esmodule")]),v._v(" "),t("li",[v._v("不能识别 commonjs 语法")]),v._v(" "),t("li",[v._v("生态不及 webpack，加载器、插件不够丰富")]),v._v(" "),t("li",[v._v("生产环境 esbuild 构建对于 css 和代码分割不够友好")]),v._v(" "),t("li",[v._v("没被大规模重度使用，会隐藏一些问题")])]),v._v(" "),t("p",[t("strong",[v._v("vite 和 webpack 的区别")])]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("webpack 是先打包再启动开发服务器，vite 是直接启动开发服务器，然后按需编译依赖文件。")])])]),v._v(" "),t("ul",[t("li",[v._v("webpack 先打包，再启动开发服务器，请求服务器时直接给予打包后的结果；vite 直接启动开发服务器，请求哪个模块再对哪个模块进行实时编译；")]),v._v(" "),t("li",[v._v("由于现代浏览器本身就支持 ES Modules，会主动发起请求去获取所需文件。vite 充分利用这点，将开发环境下的模块文件，就作为浏览器要执行的文件，而不是像 webpack 先打包，交给浏览器执行的文件是打包后的；")]),v._v(" "),t("li",[v._v("**为什么启动速度快？**由于 vite 启动的时候不需要打包，也就无需分析模块依赖、编译，所以启动速度非常快。当浏览器请求需要的模块时，再对模块进行编译，这种按需动态编译的模式，极大缩短了编译时间，当项目越大，文件越多时，vite 的开发时优势越明显；")]),v._v(" "),t("li",[v._v("**HRM 为什么速度快？**在 HRM 方面，当某个模块内容改变时，让浏览器去重新请求该模块即可，而不是像 webpack 重新将该模块的所有依赖重新编译；")]),v._v(" "),t("li",[t("strong",[v._v("不能识别 commonjs 语法")]),v._v(": 当需要打包到生产环境时，vite 使用传统的 rollup 进行打包，所以，vite 的优势是体现在开发阶段，另外，由于 vite 使用的是 ES Module，所以代码中不可以使用 CommonJs；")])]),v._v(" "),t("hr"),v._v(" "),t("ul",[t("li",[t("h2",{attrs:{id:"rollup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rollup"}},[v._v("#")]),v._v(" Rollup")])])]),v._v(" "),t("blockquote",[t("p",[v._v("Rollup 是一个"),t("strong",[v._v("模块打包工具")]),v._v(", 可以将我们按照 ESM (ES2015 Module) 规范编写的源码构建输出如下格式:")])]),v._v(" "),t("ul",[t("li",[v._v("IIFE: 自执行函数, 可通过  "),t("code",[v._v("<script>")]),v._v("  标签加载")]),v._v(" "),t("li",[v._v("AMD: 通过  "),t("code",[v._v("RequireJS")]),v._v("  加载")]),v._v(" "),t("li",[v._v("CommonJS: Node 默认的模块规范, 可通过  "),t("code",[v._v("Webpack")]),v._v("  加载")]),v._v(" "),t("li",[v._v("UMD: 兼容 IIFE, AMD, CJS 三种模块规范")]),v._v(" "),t("li",[v._v("ESM: ES2015 Module 规范, 可用  "),t("code",[v._v("Webpack")]),v._v(", "),t("code",[v._v("Rollup")]),v._v("  加载")])]),v._v(" "),t("p",[t("strong",[v._v("优点：")])]),v._v(" "),t("ol",[t("li",[v._v("支持动态导入。")]),v._v(" "),t("li",[v._v("支持 tree shaking。仅加载模块里用得到的函数以减小文件大小。")]),v._v(" "),t("li",[v._v("Scope Hoisting。 rollup 可以将所有小文件生成到一个大文件中，所有代码都在同一个函数作用域里:，  不会像 Webpack 那样用很多函数来包装模块。")]),v._v(" "),t("li",[v._v("没有其他冗余代码, 执行很快**。**除了必要的  "),t("code",[v._v("cjs")]),v._v(", "),t("code",[v._v("umd")]),v._v("  头外，bundle 代码基本和源码差不多，也没有奇怪的  "),t("code",[v._v("__webpack_require__")]),v._v(", "),t("code",[v._v("Object.defineProperty")]),v._v("  之类的东西,")])]),v._v(" "),t("p",[t("strong",[v._v("缺点：")])]),v._v(" "),t("ol",[t("li",[v._v("不支持热更新功能；")]),v._v(" "),t("li",[v._v("对于 commonjs 模块，需要额外的插件将其转化为 es2015 供 rollup 处理；")]),v._v(" "),t("li",[v._v("无法进行公共代码拆分。")])]),v._v(" "),t("p",[t("strong",[v._v("适用场景：")])]),v._v(" "),t("p",[v._v("由纯 js 开发的第三方库； 需要生成单一的 umd 文件的场景")]),v._v(" "),t("p",[t("strong",[v._v("比较（和 webpack）：")])]),v._v(" "),t("ul",[t("li",[v._v("基于权衡，Rollup 目前还不支持代码拆分（Code Splitting）和模块的热更新（HMR）")]),v._v(" "),t("li",[v._v("一般而言，对于应用使用 Webpack，对于类库使用 Rollup；")]),v._v(" "),t("li",[v._v("需要代码拆分(Code Splitting)，或者很多静态资源需要处理，再或者构建的项目需要引入很多 CommonJS 模块的依赖时，使用 webpack。代码库是基于 ES6 模块，而且希望代码能够被其他人直接使用，使用 Rollup")]),v._v(" "),t("li",[v._v("Rollup 与 Webpack 有着不同的用途，因此会共同存在，并相互支持")]),v._v(" "),t("li",[v._v("React 已经将构建工具从 Webpack 换成了 Rollup")])]),v._v(" "),t("hr"),v._v(" "),t("ul",[t("li",[t("h2",{attrs:{id:"gulp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gulp"}},[v._v("#")]),v._v(" Gulp")])])]),v._v(" "),t("blockquote",[t("p",[v._v("Gulp 是基于“流”的"),t("strong",[v._v("前端自动化构建工具")]),v._v("，采用代码优于配置的策略，更易于学习和使用，它让简单的任务简单，复杂的任务可管理。")]),v._v(" "),t("p",[v._v("它是基于 Nodejs，自动化地完成 javascript、coffee、sass、less、html/image、css 等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。")])]),v._v(" "),t("p",[t("strong",[v._v("优点：")])]),v._v(" "),t("ol",[t("li",[v._v("gulp 文档简单，学习成本低，使用简单；")]),v._v(" "),t("li",[v._v("对大量源文件可以进行流式处理，借助插件，可以对文件类型进行多种操作处理。")])]),v._v(" "),t("p",[t("strong",[v._v("缺点")]),v._v("：")]),v._v(" "),t("ol",[t("li",[v._v("不支持 tree-shaking、热更新、代码分割等；")]),v._v(" "),t("li",[v._v("gulp 对 js 模块化方案无能为力，只是对静态资源做流式处理，处理之后并未做有效的优化整合。")])]),v._v(" "),t("p",[t("strong",[v._v("适用场景：")])]),v._v(" "),t("p",[v._v("静态资源密集操作型场景，主要用于 css、图片等静态资源的处理操作。")]),v._v(" "),t("p",[t("strong",[v._v("比较（和 grunt）：")])]),v._v(" "),t("ol",[t("li",[v._v("易用 。Gulp 相比 Grunt 更简洁，而且遵循代码优于配置策略，维护 Gulp 更像是写代码。")]),v._v(" "),t("li",[v._v("高效 。Gulp 相比 Grunt 更有设计感，核心设计基于 Unix 流的概念，通过管道连接，不需要写中间文件。")]),v._v(" "),t("li",[v._v("高质量。 Gulp 的每个插件只完成一个功能，这也是 Unix 的设计原则之一，各个功能通过流进行整合并完成复杂的任务。例如：Grunt 的 imagemin 插件不仅压缩图片，同时还包括缓存功能。他表示，在 Gulp 中，缓存是另一个插件，可以被别的插件使用，这样就促进了插件的可重用性。目前官方列出的有 673 个插件。")]),v._v(" "),t("li",[v._v("易学。 Gulp 的核心 API 只有 5 个，掌握了 5 个 API 就学会了 Gulp，之后便可以通过管道流组合自己想要的任务。")]),v._v(" "),t("li",[v._v("流 。使用 Grunt 的 I/O 过程中会产生一些中间态的临时文件，一些任务生成临时文件，其它任务可能会基于临时文件再做处理并生成最终的构建后文件。而使用 Gulp 的优势就是利用流的方式进行文件的处理，通过管道将多个任务和操作连接起来，因此只有一次 I/O 的过程，流程更清晰，更纯粹。")]),v._v(" "),t("li",[v._v("代码优于配置 。维护 Gulp 更像是写代码，而且 Gulp 遵循 CommonJS 规范，因此跟写 Node 程序没有差别。")])]),v._v(" "),t("p",[t("strong",[v._v("使用：")])]),v._v(" "),t("p",[t("a",{attrs:{href:"https://www.gulpjs.com.cn/docs/getting-started/quick-start/",title:"快速入门 · gulp.js 中文文档",target:"_blank",rel:"noopener noreferrer"}},[v._v("快速入门 · gulp.js 中文文档"),t("OutboundLink")],1)]),v._v(" "),t("hr"),v._v(" "),t("ul",[t("li",[t("h2",{attrs:{id:"grunt"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#grunt"}},[v._v("#")]),v._v(" Grunt")])])]),v._v(" "),t("blockquote",[t("p",[v._v("Grunt 是一套前端自动化工具，帮助处理反复重复的任务。一般用于：编译，压缩，合并文件，简单语法检查等")])]),v._v(" "),t("p",[t("strong",[v._v("特点：")])]),v._v(" "),t("ul",[t("li",[v._v("Grunt 有一个完善的社区，插件丰富，根据"),t("a",{attrs:{href:"http://gruntjs.com/plugins",title:"社区的结果",target:"_blank",rel:"noopener noreferrer"}},[v._v("社区的结果"),t("OutboundLink")],1),v._v("显示，共计 3,439 个插件，其中 49 个官方插件。")]),v._v(" "),t("li",[v._v("它简单易学，你可以随便安装插件并配置它们。许多常见的任务都有现成的 Grunt 插件，而且有众多第三方插件，如："),t("code",[v._v("CoffeeScript")]),v._v("，"),t("code",[v._v("Handlebars")]),v._v("，"),t("code",[v._v("Jade")]),v._v("，"),t("code",[v._v("JsHint")]),v._v("，"),t("code",[v._v("Less")]),v._v("，"),t("code",[v._v("RequireJS")]),v._v("，"),t("code",[v._v("Sass")]),v._v("，"),t("code",[v._v("Styles")]),v._v("。而且通过参考文档进行配置便可以使用。")]),v._v(" "),t("li",[v._v("你不需要多先进的理念，也不需要任何经验  。")])]),v._v(" "),t("p",[t("strong",[v._v("使用：")])]),v._v(" "),t("p",[t("a",{attrs:{href:"https://www.gruntjs.net/getting-started",title:"快速入门 - Grunt: JavaScript 世界的构建工具 | Grunt 中文网",target:"_blank",rel:"noopener noreferrer"}},[v._v("快速入门 - Grunt: JavaScript 世界的构建工具 | Grunt 中文网"),t("OutboundLink")],1)]),v._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://blog.csdn.net/qq_38974163/article/details/122809736",target:"_blank",rel:"noopener noreferrer"}},[v._v("Webpack | vite | Rollup | Gulp | Grunt 比较"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=l.exports}}]);