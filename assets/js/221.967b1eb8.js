(window.webpackJsonp=window.webpackJsonp||[]).push([[221],{908:function(e,t,a){"use strict";a.r(t);var n=a(18),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("blockquote",[a("p",[e._v("此文章部分摘录自: "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render",target:"_blank",rel:"noopener noreferrer"}},[e._v("react 官网 hooks FAQ"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"hooks使用注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hooks使用注意事项"}},[e._v("#")]),e._v(" Hooks使用注意事项")]),e._v(" "),a("h3",{attrs:{id:"是否应该一直使用usecallback包裹函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#是否应该一直使用usecallback包裹函数"}},[e._v("#")]),e._v(" 是否应该一直使用useCallback包裹函数")]),e._v(" "),a("p",[e._v("例子:")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("App")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("method1")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" \n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// ...")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v("  method2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("useCallback")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 这是一个和 method1 功能一样的方法")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("div onClick"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("method1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("button"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("div onClick"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("method2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("button"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),a("p",[e._v("我们的 App 函数在每一次更新的时候都会重新执行，由于这个原因，它内部的函数也都会重新生成一次，也就是说，我们的 "),a("code",[e._v("method1")]),e._v(" 每次都会重新执行生成一遍。\n而 "),a("code",[e._v("method2")]),e._v(" 就不一样了，它是被 "),a("code",[e._v("useCallback")]),e._v(" 包裹的返回值，除非依赖变化了，不然它不会重新生成，于是，你可能就会认为 "),a("code",[e._v("method2")]),e._v(" 那种写法性能更高。")]),e._v(" "),a("p",[e._v("事实上并不一定如此:")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://cdn-1252273386.cos.ap-guangzhou.myqcloud.com/images/63061e25d5211c45e2286589bd96c86a.png",alt:""}})]),e._v(" "),a("p",[a("strong",[e._v("对于 method1")]),e._v(":  每次函数执行创建新的函数几乎是可以忽略不计的;\n"),a("strong",[e._v("对于 method2")]),e._v(": 每次 props 更新 重新执行，需要对比前后的props是否相同【增加了对比的成本】；为了能判断 useCallback 要不要更新结果，我们还要在内存保存上一次的依赖。【增加了数据存储】")]),e._v(" "),a("p",[a("strong",[e._v("useCallback建议使用的场景")])]),e._v(" "),a("blockquote",[a("p",[a("strong",[e._v("需要将函数传递给子对象")]),e._v("；")])]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// parent.tsx")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[e._v("handleClick")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("Children count"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" onClick"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("handleClick"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\n\n")])])]),a("p",[e._v("如果子组件由于其他值的更改而发生了更新，子组件会重新渲染，由于 "),a("code",[e._v("handleClick")]),e._v(" 是一个对象，每次渲染生成的 "),a("code",[e._v("handleClick")]),e._v(" 都是新的。")]),e._v(" "),a("p",[e._v("这就会导致，尽管 "),a("code",[e._v("Children")]),e._v(" 被 "),a("code",[e._v("React.memo")]),e._v(" 包裹了一层，但是还是会重新渲染，为了解决这个问题，我们就要这样写 "),a("code",[e._v("handleClick")]),e._v(" 函数了：")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" handleClick "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("useCallback")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 原来的 handleClick...")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),a("h3",{attrs:{id:"我该如何测量-dom-节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我该如何测量-dom-节点"}},[e._v("#")]),e._v(" 我该如何测量 DOM 节点？")]),e._v(" "),a("p",[e._v("获取 DOM 节点的位置或是大小的基本方式是使用 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/refs-and-the-dom.html#callback-refs",target:"_blank",rel:"noopener noreferrer"}},[e._v("callback ref"),a("OutboundLink")],1),e._v("。每当 ref 被附加到一个另一个节点，React 就会调用 callback。这里有一个 "),a("a",{attrs:{href:"https://codesandbox.io/s/l7m0v5x4v9",target:"_blank",rel:"noopener noreferrer"}},[e._v("小 demo"),a("OutboundLink")],1),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function MeasureExample() {\n  const [height, setHeight] = useState(0);\n\n  const measuredRef = useCallback(node => {    if (node !== null) {      setHeight(node.getBoundingClientRect().height);    }  }, []);\n  return (\n    <>\n      <h1 ref={measuredRef}>Hello, world</h1>      <h2>The above header is {Math.round(height)}px tall</h2>\n    </>\n  );\n}\n")])])]),a("p",[e._v("在这个案例中，我们没有选择使用 "),a("code",[e._v("useRef")]),e._v("，因为当 ref 是一个对象时它并不会把当前 ref 的值的 "),a("em",[e._v("变化")]),e._v(" 通知到我们。使用 callback ref 可以确保 "),a("a",{attrs:{href:"https://codesandbox.io/s/818zzk8m78",target:"_blank",rel:"noopener noreferrer"}},[e._v("即便子组件延迟显示被测量的节点"),a("OutboundLink")],1),e._v(" (比如为了响应一次点击)，我们依然能够在父组件接收到相关的信息，以便更新测量结果。")]),e._v(" "),a("p",[e._v("注意到我们传递了 "),a("code",[e._v("[]")]),e._v(" 作为 "),a("code",[e._v("useCallback")]),e._v(" 的依赖列表。这确保了 ref callback 不会在再次渲染时改变，因此 React 不会在非必要的时候调用它。")]),e._v(" "),a("p",[e._v("在此示例中，当且仅当组件挂载和卸载时，callback ref 才会被调用，因为渲染的 "),a("code",[e._v("<h1>")]),e._v(" 组件在整个重新渲染期间始终存在。如果你希望在每次组件调整大小时都收到通知，则可能需要使用 "),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("ResizeObserver")]),a("OutboundLink")],1),e._v(" 或基于其构建的第三方 Hook。")]),e._v(" "),a("p",[e._v("如果你愿意，你可以 "),a("a",{attrs:{href:"https://codesandbox.io/s/m5o42082xy",target:"_blank",rel:"noopener noreferrer"}},[e._v("把这个逻辑抽取出来作为"),a("OutboundLink")],1),e._v(" 一个可复用的 Hook:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function MeasureExample() {\n  const [rect, ref] = useClientRect();  return (\n    <>\n      <h1 ref={ref}>Hello, world</h1>\n      {rect !== null &&\n        <h2>The above header is {Math.round(rect.height)}px tall</h2>\n      }\n    </>\n  );\n}\n\nfunction useClientRect() {\n  const [rect, setRect] = useState(null);\n  const ref = useCallback(node => {\n    if (node !== null) {\n      setRect(node.getBoundingClientRect());\n    }\n  }, []);\n  return [rect, ref];\n}\n")])])]),a("h3",{attrs:{id:"const-thing-setthing-usestate-是什么意思"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#const-thing-setthing-usestate-是什么意思"}},[e._v("#")]),e._v(" "),a("code",[e._v("const [thing, setThing] = useState()")]),e._v(" 是什么意思？")]),e._v(" "),a("p",[e._v("如果你不熟悉这个语法，可以查看 State Hook 文档中的 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-state.html#tip-what-do-square-brackets-mean",target:"_blank",rel:"noopener noreferrer"}},[e._v("解释"),a("OutboundLink")],1),e._v(" 一节。")]),e._v(" "),a("h2",{attrs:{id:"性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[e._v("#")]),e._v(" 性能优化")]),e._v(" "),a("h3",{attrs:{id:"我可以在更新时跳过-effect-吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我可以在更新时跳过-effect-吗"}},[e._v("#")]),e._v(" 我可以在更新时跳过 effect 吗？")]),e._v(" "),a("p",[e._v("可以的。参见 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect",target:"_blank",rel:"noopener noreferrer"}},[e._v("条件式的发起 effect"),a("OutboundLink")],1),e._v("。注意，忘记处理更新常会 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-effect.html#explanation-why-effects-run-on-each-update",target:"_blank",rel:"noopener noreferrer"}},[e._v("导致 bug"),a("OutboundLink")],1),e._v("，这也正是我们没有默认使用条件式 effect 的原因。")]),e._v(" "),a("h3",{attrs:{id:"在依赖列表中省略函数是否安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在依赖列表中省略函数是否安全"}},[e._v("#")]),e._v(" 在依赖列表中省略函数是否安全？")]),e._v(" "),a("p",[e._v("一般来说，不安全。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Example({ someProp }) {\n  function doSomething() {\n    console.log(someProp);  }\n\n  useEffect(() => {\n    doSomething();\n  }, []); // 🔴 这样不安全（它调用的 `doSomething` 函数使用了 `someProp`）}\n")])])]),a("p",[e._v("要记住 effect 外部的函数使用了哪些 props 和 state 很难。这也是为什么 "),a("strong",[e._v("通常你会想要在 effect "),a("em",[e._v("内部")]),e._v(" 去声明它所需要的函数。")]),e._v(" 这样就能容易的看出那个 effect 依赖了组件作用域中的哪些值：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Example({ someProp }) {\n  useEffect(() => {\n    function doSomething() {\n      console.log(someProp);    }\n\n    doSomething();\n  }, [someProp]); // ✅ 安全（我们的 effect 仅用到了 `someProp`）}\n")])])]),a("p",[e._v("如果这样之后我们依然没用到组件作用域中的任何值，就可以安全地把它指定为 "),a("code",[e._v("[]")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("useEffect(() => {\n  function doSomething() {\n    console.log('hello');\n  }\n\n  doSomething();\n}, []); // ✅ 在这个例子中是安全的，因为我们没有用到组件作用域中的 *任何* 值\n")])])]),a("p",[e._v("根据你的用例，下面列举了一些其他的办法。")]),e._v(" "),a("blockquote",[a("p",[e._v("注意")]),e._v(" "),a("p",[e._v("我们提供了一个 "),a("a",{attrs:{href:"https://github.com/facebook/react/issues/14920",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("exhaustive-deps")]),a("OutboundLink")],1),e._v(" ESLint 规则作为 "),a("a",{attrs:{href:"https://www.npmjs.com/package/eslint-plugin-react-hooks#installation",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("eslint-plugin-react-hooks")]),a("OutboundLink")],1),e._v(" 包的一部分。它会帮助你找出无法一致地处理更新的组件。")])]),e._v(" "),a("p",[e._v("让我们来看看这有什么关系。")]),e._v(" "),a("p",[e._v("如果你指定了一个 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect",target:"_blank",rel:"noopener noreferrer"}},[e._v("依赖列表"),a("OutboundLink")],1),e._v(" 作为 "),a("code",[e._v("useEffect")]),e._v("、"),a("code",[e._v("useLayoutEffect")]),e._v("、"),a("code",[e._v("useMemo")]),e._v("、"),a("code",[e._v("useCallback")]),e._v(" 或 "),a("code",[e._v("useImperativeHandle")]),e._v(" 的最后一个参数，它必须包含回调中的所有值，并参与 React 数据流。这就包括 props、state，以及任何由它们衍生而来的东西。")]),e._v(" "),a("p",[a("strong",[e._v("只有")]),e._v(" 当函数（以及它所调用的函数）不引用 props、state 以及由它们衍生而来的值时，你才能放心地把它们从依赖列表中省略。下面这个案例有一个 Bug：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function ProductPage({ productId }) {\n  const [product, setProduct] = useState(null);\n\n  async function fetchProduct() {\n    const response = await fetch('http://myapi/product/' + productId); // 使用了 productId prop    const json = await response.json();\n    setProduct(json);\n  }\n\n  useEffect(() => {\n    fetchProduct();\n  }, []); // 🔴 这样是无效的，因为 `fetchProduct` 使用了 `productId`  // ...\n}\n")])])]),a("p",[a("strong",[e._v("推荐的修复方案是把那个函数移动到你的 effect "),a("em",[e._v("内部")])]),e._v("。这样就能很容易的看出来你的 effect 使用了哪些 props 和 state，并确保它们都被声明了：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function ProductPage({ productId }) {\n  const [product, setProduct] = useState(null);\n\n  useEffect(() => {\n    // 把这个函数移动到 effect 内部后，我们可以清楚地看到它用到的值。    async function fetchProduct() {      const response = await fetch('http://myapi/product/' + productId);      const json = await response.json();      setProduct(json);    }\n    fetchProduct();\n  }, [productId]); // ✅ 有效，因为我们的 effect 只用到了 productId  // ...\n}\n")])])]),a("p",[e._v("这同时也允许你通过 effect 内部的局部变量来处理无序的响应：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  useEffect(() => {\n    let ignore = false;    async function fetchProduct() {\n      const response = await fetch('http://myapi/product/' + productId);\n      const json = await response.json();\n      if (!ignore) setProduct(json);    }\n\n    fetchProduct();\n    return () => { ignore = true };  }, [productId]);\n")])])]),a("p",[e._v("我们把这个函数移动到 effect 内部，这样它就不用出现在它的依赖列表中了。")]),e._v(" "),a("blockquote",[a("p",[e._v("提示")]),e._v(" "),a("p",[e._v("看看 "),a("a",{attrs:{href:"https://codesandbox.io/s/jvvkoo8pq3",target:"_blank",rel:"noopener noreferrer"}},[e._v("这个小 demo"),a("OutboundLink")],1),e._v(" 和 "),a("a",{attrs:{href:"https://www.robinwieruch.de/react-hooks-fetch-data/",target:"_blank",rel:"noopener noreferrer"}},[e._v("这篇文章"),a("OutboundLink")],1),e._v(" 来了解更多关于如何用 Hook 进行数据获取。")])]),e._v(" "),a("p",[a("strong",[e._v("如果出于某些原因你 "),a("em",[e._v("无法")]),e._v(" 把一个函数移动到 effect 内部，还有一些其他办法：")])]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("你可以尝试把那个函数移动到你的组件之外")]),e._v("。那样一来，这个函数就肯定不会依赖任何 props 或 state，并且也不用出现在依赖列表中了。")]),e._v(" "),a("li",[e._v("如果你所调用的方法是一个纯计算，并且可以在渲染时调用，你可以 "),a("strong",[e._v("转而在 effect 之外调用它，")]),e._v(" 并让 effect 依赖于它的返回值。")]),e._v(" "),a("li",[e._v("万不得已的情况下，你可以 "),a("strong",[e._v("把函数加入 effect 的依赖但 "),a("em",[e._v("把它的定义包裹")])]),e._v(" 进 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("useCallback")]),a("OutboundLink")],1),e._v(" Hook。这就确保了它不随渲染而改变，除非 "),a("em",[e._v("它自身")]),e._v(" 的依赖发生了改变：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function ProductPage({ productId }) {\n  // ✅ 用 useCallback 包裹以避免随渲染发生改变  const fetchProduct = useCallback(() => {    // ... Does something with productId ...  }, [productId]); // ✅ useCallback 的所有依赖都被指定了\n  return <ProductDetails fetchProduct={fetchProduct} />;\n}\n\nfunction ProductDetails({ fetchProduct }) {\n  useEffect(() => {\n    fetchProduct();\n  }, [fetchProduct]); // ✅ useEffect 的所有依赖都被指定了\n  // ...\n}\n")])])]),a("p",[e._v("注意在上面的案例中，我们 "),a("strong",[e._v("需要")]),e._v(" 让函数出现在依赖列表中。这确保了 "),a("code",[e._v("ProductPage")]),e._v(" 的 "),a("code",[e._v("productId")]),e._v(" prop 的变化会自动触发 "),a("code",[e._v("ProductDetails")]),e._v(" 的重新获取。")]),e._v(" "),a("h3",{attrs:{id:"如果我的-effect-的依赖频繁变化-我该怎么办"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果我的-effect-的依赖频繁变化-我该怎么办"}},[e._v("#")]),e._v(" 如果我的 effect 的依赖频繁变化，我该怎么办？")]),e._v(" "),a("p",[e._v("有时候，你的 effect 可能会使用一些频繁变化的值。你可能会忽略依赖列表中 state，但这通常会引起 Bug：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1); // 这个 effect 依赖于 `count` state    }, 1000);\n    return () => clearInterval(id);\n  }, []); // 🔴 Bug: `count` 没有被指定为依赖\n  return <h1>{count}</h1>;\n}\n")])])]),a("p",[e._v("传入空的依赖数组 "),a("code",[e._v("[]")]),e._v("，意味着该 hook 只在组件挂载时运行一次，并非重新渲染时。但如此会有问题，在 "),a("code",[e._v("setInterval")]),e._v(" 的回调中，"),a("code",[e._v("count")]),e._v(" 的值不会发生变化。因为当 effect 执行时，我们会创建一个闭包，并将 "),a("code",[e._v("count")]),e._v(" 的值被保存在该闭包当中，且初值为 "),a("code",[e._v("0")]),e._v("。每隔一秒，回调就会执行 "),a("code",[e._v("setCount(0 + 1)")]),e._v("，因此，"),a("code",[e._v("count")]),e._v(" 永远不会超过 1。")]),e._v(" "),a("p",[e._v("指定 "),a("code",[e._v("[count]")]),e._v(" 作为依赖列表就能修复这个 Bug，但会导致每次改变发生时定时器都被重置。事实上，每个 "),a("code",[e._v("setInterval")]),e._v(" 在被清除前（类似于 "),a("code",[e._v("setTimeout")]),e._v("）都会调用一次。但这并不是我们想要的。要解决这个问题，我们可以使用 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#functional-updates",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("setState")]),e._v(" 的函数式更新形式"),a("OutboundLink")],1),e._v("。它允许我们指定 state 该 "),a("em",[e._v("如何")]),e._v(" 改变而不用引用 "),a("em",[e._v("当前")]),e._v(" state：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + 1); // ✅ 在这不依赖于外部的 `count` 变量    }, 1000);\n    return () => clearInterval(id);\n  }, []); // ✅ 我们的 effect 不使用组件作用域中的任何变量\n  return <h1>{count}</h1>;\n}\n")])])]),a("p",[e._v("（"),a("code",[e._v("setCount")]),e._v(" 函数的身份是被确保稳定的，所以可以放心的省略掉）")]),e._v(" "),a("p",[e._v("此时，"),a("code",[e._v("setInterval")]),e._v(" 的回调依旧每秒调用一次，但每次 "),a("code",[e._v("setCount")]),e._v(" 内部的回调取到的 "),a("code",[e._v("count")]),e._v(" 是最新值（在回调中变量命名为 "),a("code",[e._v("c")]),e._v("）。")]),e._v(" "),a("p",[e._v("在一些更加复杂的场景中（比如一个 state 依赖于另一个 state），尝试用 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("useReducer")]),e._v(" Hook"),a("OutboundLink")],1),e._v(" 把 state 更新逻辑移到 effect 之外。"),a("a",{attrs:{href:"https://adamrackis.dev/state-and-use-reducer/",target:"_blank",rel:"noopener noreferrer"}},[e._v("这篇文章"),a("OutboundLink")],1),e._v(" 提供了一个你该如何做到这一点的案例。 "),a("strong",[a("code",[e._v("useReducer")]),e._v(" 的 "),a("code",[e._v("dispatch")]),e._v(" 的身份永远是稳定的")]),e._v(" —— 即使 reducer 函数是定义在组件内部并且依赖 props。")]),e._v(" "),a("p",[e._v("万不得已的情况下，如果你想要类似 class 中的 "),a("code",[e._v("this")]),e._v(" 的功能，你可以 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables",target:"_blank",rel:"noopener noreferrer"}},[e._v("使用一个 ref"),a("OutboundLink")],1),e._v(" 来保存一个可变的变量。然后你就可以对它进行读写了。举个例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Example(props) {\n  // 把最新的 props 保存在一个 ref 中  const latestProps = useRef(props);  useEffect(() => {    latestProps.current = props;  });\n  useEffect(() => {\n    function tick() {\n      // 在任何时候读取最新的 props      console.log(latestProps.current);    }\n\n    const id = setInterval(tick, 1000);\n    return () => clearInterval(id);\n  }, []); // 这个 effect 从不会重新执行}\n")])])]),a("p",[e._v("仅当你实在找不到更好办法的时候才这么做，因为依赖于变更会使得组件更难以预测。如果有某些特定的模式无法很好地转化成这样，"),a("a",{attrs:{href:"https://github.com/facebook/react/issues/new",target:"_blank",rel:"noopener noreferrer"}},[e._v("发起一个 issue"),a("OutboundLink")],1),e._v(" 并配上可运行的实例代码以便，我们会尽可能帮助你。")]),e._v(" "),a("h3",{attrs:{id:"我该如何实现-shouldcomponentupdate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#我该如何实现-shouldcomponentupdate"}},[e._v("#")]),e._v(" 我该如何实现 "),a("code",[e._v("shouldComponentUpdate")]),e._v("?")]),e._v(" "),a("p",[e._v("你可以用 "),a("code",[e._v("React.memo")]),e._v(" 包裹一个组件来对它的 props 进行浅比较：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const Button = React.memo((props) => {\n  // 你的组件\n});\n")])])]),a("p",[e._v("这不是一个 Hook 因为它的写法和 Hook 不同。"),a("code",[e._v("React.memo")]),e._v(" 等效于 "),a("code",[e._v("PureComponent")]),e._v("，但它只比较 props。（你也可以通过第二个参数指定一个自定义的比较函数来比较新旧 props。如果函数返回 true，就会跳过更新。）")]),e._v(" "),a("p",[a("code",[e._v("React.memo")]),e._v(" 不比较 state，因为没有单一的 state 对象可供比较。但你也可以让子节点变为纯组件，或者 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-memoize-calculations",target:"_blank",rel:"noopener noreferrer"}},[e._v("用 "),a("code",[e._v("useMemo")]),e._v(" 优化每一个具体的子节点"),a("OutboundLink")],1),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"如何记忆计算结果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何记忆计算结果"}},[e._v("#")]),e._v(" 如何记忆计算结果？")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("useMemo")]),a("OutboundLink")],1),e._v(" Hook 允许你通过「记住」上一次计算结果的方式在多次渲染的之间缓存计算结果：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n")])])]),a("p",[e._v("这行代码会调用 "),a("code",[e._v("computeExpensiveValue(a, b)")]),e._v("。但如果依赖数组 "),a("code",[e._v("[a, b]")]),e._v(" 自上次赋值以来没有改变过，"),a("code",[e._v("useMemo")]),e._v(" 会跳过二次调用，只是简单复用它上一次返回的值。")]),e._v(" "),a("p",[e._v("记住，传给 "),a("code",[e._v("useMemo")]),e._v(" 的函数是在渲染期间运行的。不要在其中做任何你通常不会在渲染期间做的事。举个例子，副作用属于 "),a("code",[e._v("useEffect")]),e._v("，而不是 "),a("code",[e._v("useMemo")]),e._v("。")]),e._v(" "),a("p",[e._v("**你可以把 "),a("code",[e._v("useMemo")]),e._v(" 作为一种性能优化的手段，但不要把它当做一种语义上的保证。**未来，React 可能会选择「忘掉」一些之前记住的值并在下一次渲染时重新计算它们，比如为离屏组件释放内存。建议自己编写相关代码以便没有 "),a("code",[e._v("useMemo")]),e._v(" 也能正常工作 —— 然后把它加入性能优化。（在某些取值必须 "),a("em",[e._v("从不")]),e._v(" 被重新计算的罕见场景，你可以 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily",target:"_blank",rel:"noopener noreferrer"}},[e._v("惰性初始化"),a("OutboundLink")],1),e._v(" 一个 ref。）")]),e._v(" "),a("p",[e._v("方便起见，"),a("code",[e._v("useMemo")]),e._v(" 也允许你跳过一次子节点的昂贵的重新渲染：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Parent({ a, b }) {\n  // Only re-rendered if `a` changes:\n  const child1 = useMemo(() => <Child1 a={a} />, [a]);\n  // Only re-rendered if `b` changes:\n  const child2 = useMemo(() => <Child2 b={b} />, [b]);\n  return (\n    <>\n      {child1}\n      {child2}\n    </>\n  )\n}\n")])])]),a("p",[e._v("注意这种方式在循环中是无效的，因为 Hook 调用 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-rules.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("不能"),a("OutboundLink")],1),e._v(" 被放在循环中。但你可以为列表项抽取一个单独的组件，并在其中调用 "),a("code",[e._v("useMemo")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"如何惰性创建昂贵的对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何惰性创建昂贵的对象"}},[e._v("#")]),e._v(" 如何惰性创建昂贵的对象？")]),e._v(" "),a("p",[e._v("如果依赖数组的值相同，"),a("code",[e._v("useMemo")]),e._v(" 允许你 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-memoize-calculations",target:"_blank",rel:"noopener noreferrer"}},[e._v("记住一次昂贵的计算"),a("OutboundLink")],1),e._v("。但是，这仅作为一种提示，并不 "),a("em",[e._v("保证")]),e._v(" 计算不会重新运行。但有时候需要确保一个对象仅被创建一次。")]),e._v(" "),a("p",[a("strong",[e._v("第一个常见的使用场景是当创建初始 state 很昂贵时：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Table(props) {\n  // ⚠️ createRows() 每次渲染都会被调用\n  const [rows, setRows] = useState(createRows(props.count));\n  // ...\n}\n")])])]),a("p",[e._v("为避免重新创建被忽略的初始 state，我们可以传一个 "),a("strong",[e._v("函数")]),e._v(" 给 "),a("code",[e._v("useState")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Table(props) {\n  // ✅ createRows() 只会被调用一次\n  const [rows, setRows] = useState(() => createRows(props.count));\n  // ...\n}\n")])])]),a("p",[e._v("React 只会在首次渲染时调用这个函数。参见 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usestate",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("useState")]),e._v(" API 参考"),a("OutboundLink")],1),e._v("。")]),e._v(" "),a("p",[e._v("**你或许也会偶尔想要避免重新创建 "),a("code",[e._v("useRef()")]),e._v(" 的初始值。**举个例子，或许你想确保某些命令式的 class 实例只被创建一次：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Image(props) {\n  // ⚠️ IntersectionObserver 在每次渲染都会被创建\n  const ref = useRef(new IntersectionObserver(onIntersect));\n  // ...\n}\n")])])]),a("p",[a("code",[e._v("useRef")]),e._v(" "),a("strong",[e._v("不会")]),e._v(" 像 "),a("code",[e._v("useState")]),e._v(" 那样接受一个特殊的函数重载。相反，你可以编写你自己的函数来创建并将其设为惰性的：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Image(props) {\n  const ref = useRef(null);\n\n  // ✅ IntersectionObserver 只会被惰性创建一次\n  function getObserver() {\n    if (ref.current === null) {\n      ref.current = new IntersectionObserver(onIntersect);\n    }\n    return ref.current;\n  }\n\n  // 当你需要时，调用 getObserver()\n  // ...\n}\n")])])]),a("p",[e._v("这避免了我们在一个对象被首次真正需要之前就创建它。如果你使用 Flow 或 TypeScript，你还可以为了方便给 "),a("code",[e._v("getObserver()")]),e._v(" 一个不可为 null 的类型。")]),e._v(" "),a("h3",{attrs:{id:"hook-会因为在渲染时创建函数而变慢吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hook-会因为在渲染时创建函数而变慢吗"}},[e._v("#")]),e._v(" Hook 会因为在渲染时创建函数而变慢吗？")]),e._v(" "),a("p",[e._v("不会。在现代浏览器中，闭包和类的原始性能只有在极端场景下才会有明显的差别。")]),e._v(" "),a("p",[e._v("除此之外，可以认为 Hook 的设计在某些方面更加高效：")]),e._v(" "),a("ul",[a("li",[e._v("Hook 避免了 class 需要的额外开支，像是创建类实例和在构造函数中绑定事件处理器的成本。")]),e._v(" "),a("li",[a("strong",[e._v("符合语言习惯的代码在使用 Hook 时不需要很深的组件树嵌套")]),e._v("。这个现象在使用高阶组件、render props、和 context 的代码库中非常普遍。组件树小了，React 的工作量也随之减少。")])]),e._v(" "),a("p",[e._v("传统上认为，在 React 中使用内联函数对性能的影响，与每次渲染都传递新的回调会如何破坏子组件的 "),a("code",[e._v("shouldComponentUpdate")]),e._v(" 优化有关。Hook 从三个方面解决了这个问题。")]),e._v(" "),a("ul",[a("li",[a("p",[a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("useCallback")]),a("OutboundLink")],1),e._v(" Hook 允许你在重新渲染之间保持对相同的回调引用以使得 "),a("code",[e._v("shouldComponentUpdate")]),e._v(" 继续工作：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 除非 `a` 或 `b` 改变，否则不会变\nconst memoizedCallback = useCallback(() => {  doSomething(a, b);\n}, [a, b]);\n")])])])]),e._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-memoize-calculations",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("useMemo")]),a("OutboundLink")],1),e._v(" Hook 使得控制具体子节点何时更新变得更容易，减少了对纯组件的需要。")])]),e._v(" "),a("li",[a("p",[e._v("最后，"),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("useReducer")]),a("OutboundLink")],1),e._v(" Hook 减少了对深层传递回调的依赖，正如下面解释的那样。")])])]),e._v(" "),a("h3",{attrs:{id:"如何避免向下传递回调"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何避免向下传递回调"}},[e._v("#")]),e._v(" 如何避免向下传递回调？")]),e._v(" "),a("p",[e._v("我们已经发现大部分人并不喜欢在组件树的每一层手动传递回调。尽管这种写法更明确，但这给人感觉像错综复杂的管道工程一样麻烦。")]),e._v(" "),a("p",[e._v("在大型的组件树中，我们推荐的替代方案是通过 context 用 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("useReducer")]),a("OutboundLink")],1),e._v(" 往下传一个 "),a("code",[e._v("dispatch")]),e._v(" 函数：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const TodosDispatch = React.createContext(null);\n\nfunction TodosApp() {\n  // 提示：`dispatch` 不会在重新渲染之间变化  const [todos, dispatch] = useReducer(todosReducer);\n  return (\n    <TodosDispatch.Provider value={dispatch}>\n      <DeepTree todos={todos} />\n    </TodosDispatch.Provider>\n  );\n}\n")])])]),a("p",[a("code",[e._v("TodosApp")]),e._v(" 内部组件树里的任何子节点都可以使用 "),a("code",[e._v("dispatch")]),e._v(" 函数来向上传递 actions 到 "),a("code",[e._v("TodosApp")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function DeepChild(props) {\n  // 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。  const dispatch = useContext(TodosDispatch);\n  function handleClick() {\n    dispatch({ type: 'add', text: 'hello' });\n  }\n\n  return (\n    <button onClick={handleClick}>Add todo</button>\n  );\n}\n")])])]),a("p",[e._v("总而言之，从维护的角度来这样看更加方便（不用不断转发回调），同时也避免了回调的问题。像这样向下传递 "),a("code",[e._v("dispatch")]),e._v(" 是处理深度更新的推荐模式。")]),e._v(" "),a("p",[e._v("注意，你依然可以选择将应用的 "),a("em",[e._v("state")]),e._v(" 作为 props（更显明确）向下传递或者使用 context（对很深的更新而言更加方便）向下传递。如果你选择使用 context 来向下传递 state，请使用两种不同的 context 类型传递 state 和 dispatch —— 由于 "),a("code",[e._v("dispatch")]),e._v(" context 永远不会变，因此读取它的组件不需要重新渲染，除非这些组件也需要用到应用程序的 state。")]),e._v(" "),a("h3",{attrs:{id:"如何从-usecallback-读取一个经常变化的值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何从-usecallback-读取一个经常变化的值"}},[e._v("#")]),e._v(" 如何从 "),a("code",[e._v("useCallback")]),e._v(" 读取一个经常变化的值？")]),e._v(" "),a("blockquote",[a("p",[e._v("注意")]),e._v(" "),a("p",[e._v("我们推荐 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down",target:"_blank",rel:"noopener noreferrer"}},[e._v("在 context 中向下传递 "),a("code",[e._v("dispatch")]),a("OutboundLink")],1),e._v(" 而非在 props 中使用独立的回调。下面的方法仅仅出于文档完整性考虑，以及作为一条出路在此提及。")])]),e._v(" "),a("p",[e._v("在某些罕见场景中，你可能会需要用 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("useCallback")]),a("OutboundLink")],1),e._v(" 记住一个回调，但由于内部函数必须经常重新创建，记忆效果不是很好。如果你想要记住的函数是一个事件处理器并且在渲染期间没有被用到，你可以 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables",target:"_blank",rel:"noopener noreferrer"}},[e._v("把 ref 当做实例变量"),a("OutboundLink")],1),e._v(" 来用，并手动把最后提交的值保存在它当中：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Form() {\n  const [text, updateText] = useState('');\n  const textRef = useRef();\n\n  useEffect(() => {\n    textRef.current = text; // 把它写入 ref  });\n\n  const handleSubmit = useCallback(() => {\n    const currentText = textRef.current; // 从 ref 读取它    alert(currentText);\n  }, [textRef]); // 不要像 [text] 那样重新创建 handleSubmit\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n")])])]),a("p",[e._v("这是一个比较麻烦的模式，但这表示如果你需要的话你可以用这条出路进行优化。如果你把它抽取成一个自定义 Hook 的话会更加好受些：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Form() {\n  const [text, updateText] = useState('');\n  // 即便 `text` 变了也会被记住:\n  const handleSubmit = useEventCallback(() => {    alert(text);\n  }, [text]);\n\n  return (\n    <>\n      <input value={text} onChange={e => updateText(e.target.value)} />\n      <ExpensiveTree onSubmit={handleSubmit} />\n    </>\n  );\n}\n\nfunction useEventCallback(fn, dependencies) {  const ref = useRef(() => {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn, ...dependencies]);\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]);\n}\n")])])]),a("p",[e._v("无论如何，我们都 "),a("strong",[e._v("不推荐使用这种模式")]),e._v(" ，只是为了文档的完整性而把它展示在这里。相反的，我们更倾向于 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down",target:"_blank",rel:"noopener noreferrer"}},[e._v("避免向下深入传递回调"),a("OutboundLink")],1),e._v("。")]),e._v(" "),a("h2",{attrs:{id:"底层原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#底层原理"}},[e._v("#")]),e._v(" 底层原理")]),e._v(" "),a("h3",{attrs:{id:"react-是如何把对-hook-的调用和组件联系起来的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-是如何把对-hook-的调用和组件联系起来的"}},[e._v("#")]),e._v(" React 是如何把对 Hook 的调用和组件联系起来的？")]),e._v(" "),a("p",[e._v("React 保持对当前渲染中的组件的追踪。多亏了 "),a("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-rules.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Hook 规范"),a("OutboundLink")],1),e._v("，我们得知 Hook 只会在 React 组件中被调用（或自定义 Hook —— 同样只会在 React 组件中被调用）。")]),e._v(" "),a("p",[e._v("每个组件内部都有一个「记忆单元格」列表。它们只不过是我们用来存储一些数据的 JavaScript 对象。当你用 "),a("code",[e._v("useState()")]),e._v(" 调用一个 Hook 的时候，它会读取当前的单元格（或在首次渲染时将其初始化），然后把指针移动到下一个。这就是多个 "),a("code",[e._v("useState()")]),e._v(" 调用会得到各自独立的本地 state 的原因。")])])}),[],!1,null,null,null);t.default=s.exports}}]);