(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{486:function(t,e,a){"use strict";a.r(e);var s=a(1),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("本文作为自己深入学习 "),a("code",[t._v("React Fiber")]),t._v("(React v16.8.6)的理解,本篇仅介绍大致流程,Fiber 详细源码本文不作细节描述。")]),t._v(" "),a("h2",{attrs:{id:"fiber-出现的背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiber-出现的背景","aria-hidden":"true"}},[t._v("#")]),t._v(" "),a("code",[t._v("Fiber")]),t._v(" 出现的背景")]),t._v(" "),a("p",[t._v("首先要知道的是,JavaScript 引擎和页面渲染引擎"),a("strong",[t._v("两个线程是互斥的")]),t._v(",当其中一个线程执行时,另一个线程只能挂起等待。")]),t._v(" "),a("p",[t._v("在这样的机制下,如果 "),a("code",[t._v("JavaScript")]),t._v(" 线程长时间地占用了主线程,那么渲染层面的更新就不得不长时间地等待,界面长时间不更新,会导致页面响应度变差,用户可能会感觉到卡顿。")]),t._v(" "),a("p",[t._v("而这正是 React 15 的 "),a("code",[t._v("Stack Reconciler")]),t._v(" 所面临的问题,即是 "),a("code",[t._v("JavaScript")]),t._v(" 对主线程的超时占用问题。"),a("code",[t._v("Stack Reconciler")]),t._v(" 是一个同步的递归过程,使用的是 "),a("code",[t._v("JavaScript")]),t._v(" 引擎自身的函数调用栈,它会一直执行到栈空为止,所以当 "),a("code",[t._v("React")]),t._v(" 在渲染组件时,从开始到渲染完成整个过程是一气呵成的。如果渲染的组件比较庞大,js 执行会占据主线程较长时间,会导致页面响应度变差。")]),t._v(" "),a("p",[t._v("而且所有的任务都是按照先后顺序,没有区分优先级,这样就会导致优先级比较高的任务无法被优先执行。")]),t._v(" "),a("h2",{attrs:{id:"fiber-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiber-是什么","aria-hidden":"true"}},[t._v("#")]),t._v(" "),a("code",[t._v("Fiber")]),t._v(" 是什么")]),t._v(" "),a("p",[a("code",[t._v("Fiber")]),t._v(" 的中文翻译叫纤程,与进程、线程同为程序执行过程,Fiber 就是比线程还要纤细的一个过程。纤程意在对渲染过程实现进行更加精细的控制。")]),t._v(" "),a("p",[t._v("从架构角度来看,"),a("code",[t._v("Fiber")]),t._v(" 是对 "),a("code",[t._v("React")]),t._v(" 核心算法（即调和过程）的重写。")]),t._v(" "),a("p",[t._v("从编码角度来看,"),a("code",[t._v("Fiber")]),t._v(" 是 "),a("code",[t._v("React")]),t._v(" 内部所定义的一种数据结构,它是 "),a("code",[t._v("Fiber")]),t._v(' 树结构的节点单位,也就是 React 16 新架构下的"虚拟 DOM"。')]),t._v(" "),a("p",[t._v("一个 fiber 就是一个 "),a("code",[t._v("JavaScript")]),t._v(" 对象,Fiber 的数据结构如下：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[t._v("type Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用于标记fiber的WorkTag类型,主要表示当前fiber代表的组件类型如FunctionComponent、ClassComponent等")]),t._v("\n  tag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" WorkTag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ReactElement里面的key")]),t._v("\n  key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ReactElement.type,调用`createElement`的第一个参数")]),t._v("\n  elementType"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The resolved function/class/ associated with this fiber.")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 表示当前代表的节点类型")]),t._v("\n  type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 表示当前FiberNode对应的element组件实例")]),t._v("\n  stateNode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向他在Fiber节点树中的`parent`,用来在处理完这个节点之后向上返回")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向自己的第一个子节点")]),t._v("\n  child"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向自己的兄弟结构,兄弟节点的return指向同一个父节点")]),t._v("\n  sibling"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  ref"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("handle"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" mixed")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" _stringRef"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v("string "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" RefObject"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前处理过程中的组件props对象")]),t._v("\n  pendingProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上一次渲染完成之后的props")]),t._v("\n  memoizedProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 该Fiber对应的组件产生的Update会存放在这个队列里面")]),t._v("\n  updateQueue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" UpdateQueue"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("any"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 上一次渲染的时候的state")]),t._v("\n  memoizedState"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 一个列表,存放这个Fiber依赖的context")]),t._v("\n  firstContextDependency"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ContextDependency"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("mixed"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  mode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" TypeOfMode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Effect")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用来记录Side Effect")]),t._v("\n  effectTag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" SideEffectTag"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 单链表用来快速查找下一个side effect")]),t._v("\n  nextEffect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子树中第一个side effect")]),t._v("\n  firstEffect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子树中最后一个side effect")]),t._v("\n  lastEffect"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 代表任务在未来的哪个时间点应该被完成,之后版本改名为 lanes")]),t._v("\n  expirationTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ExpirationTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 快速确定子树中是否有不在等待的变化")]),t._v("\n  childExpirationTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ExpirationTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// fiber的版本池,即记录fiber更新过程,便于恢复")]),t._v("\n  alternate"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token template-string"}},[a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("Fiber")]),a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("blockquote",[a("p",[t._v("在 2020 年 5 月,以 expirationTime 属性为代表的优先级模型被 lanes 取代。")])]),t._v(" "),a("h2",{attrs:{id:"fiber-如何解决问题的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiber-如何解决问题的","aria-hidden":"true"}},[t._v("#")]),t._v(" "),a("code",[t._v("Fiber")]),t._v(" 如何解决问题的")]),t._v(" "),a("p",[a("code",[t._v("Fiber")]),t._v(" "),a("strong",[t._v("把一个渲染任务分解为多个渲染任务")]),t._v(',而不是一次性完成,把每一个分割得很细的任务视作一个"执行单元",React 就会检查现在还剩多少时间,如果没有时间就将控制权让出去,故任务会被分散到多个帧里面,中间可以返回至主进程控制执行其他任务,最终实现更流畅的用户体验。')]),t._v(" "),a("p",[t._v('即是实现了"增量渲染",实现了可中断与恢复,恢复后也可以复用之前的中间状态,并给不同的任务赋予不同的优先级,其中每个任务更新单元为 React Element 对应的 '),a("code",[t._v("Fiber")]),t._v(" 节点。")]),t._v(" "),a("h2",{attrs:{id:"fiber-实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiber-实现原理","aria-hidden":"true"}},[t._v("#")]),t._v(" "),a("code",[t._v("Fiber")]),t._v(" 实现原理")]),t._v(" "),a("p",[t._v("实现的方式是"),a("code",[t._v("requestIdleCallback")]),t._v("这一 API,但 React 团队 polyfill 了这个 API,使其对比原生的浏览器兼容性更好且拓展了特性。")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("window.requestIdleCallback()")]),t._v("方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作,而不会影响延迟关键事件,如动画和输入响应。函数一般会按先进先调用的顺序执行,然而,如果回调函数指定了执行超时时间 timeout,则有可能为了在超时前执行函数而打乱执行顺序。")])]),t._v(" "),a("p",[a("code",[t._v("requestIdleCallback")]),t._v("回调的执行的前提条件是当前浏览器处于空闲状态。")]),t._v(" "),a("p",[t._v("即"),a("code",[t._v("requestIdleCallback")]),t._v("的作用是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务。首先 React 中任务切割为多个步骤,分批完成。在完成一部分任务之后,将控制权交回给浏览器,让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间,再继续之前 React 未完成的任务,是一种合作式调度。")]),t._v(" "),a("p",[t._v("简而言之,由浏览器给我们分配执行时间片,我们要按照约定在这个时间内执行完毕,并将控制权还给浏览器。")]),t._v(" "),a("p",[t._v("React 16 的"),a("code",[t._v("Reconciler")]),t._v("基于 "),a("code",[t._v("Fiber")]),t._v(" 节点实现,被称为 "),a("code",[t._v("Fiber")]),t._v(" Reconciler。")]),t._v(" "),a("p",[t._v("作为静态的数据结构来说,每个 "),a("code",[t._v("Fiber")]),t._v(" 节点对应一个 React element,保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。")]),t._v(" "),a("p",[t._v("作为动态的工作单元来说,每个 "),a("code",[t._v("Fiber")]),t._v(" 节点保存了本次更新中该组件改变的状态、要执行的工作。")]),t._v(" "),a("p",[t._v("每个 "),a("code",[t._v("Fiber")]),t._v(" 节点有个对应的 React element,多个 "),a("code",[t._v("Fiber")]),t._v(" 节点是如何连接形成树呢？靠如下三个属性：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向父级Fiber节点")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("return "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向子Fiber节点")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("child "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向右边第一个兄弟Fiber节点")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sibling "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h2",{attrs:{id:"fiber-架构核心"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiber-架构核心","aria-hidden":"true"}},[t._v("#")]),t._v(" "),a("code",[t._v("Fiber")]),t._v(" 架构核心")]),t._v(" "),a("p",[a("code",[t._v("Fiber")]),t._v(" 架构可以分为三层：")]),t._v(" "),a("ul",[a("li",[t._v("Scheduler 调度器 —— 调度任务的优先级,高优任务优先进入 Reconciler")]),t._v(" "),a("li",[t._v("Reconciler 协调器 —— 负责找出变化的组件")]),t._v(" "),a("li",[t._v("Renderer 渲染器 —— 负责将变化的组件渲染到页面上")])]),t._v(" "),a("p",[t._v("相比 React15,React16 多了"),a("strong",[t._v("Scheduler（调度器）")]),t._v(",调度器的作用是调度更新的优先级。")]),t._v(" "),a("p",[t._v("在新的架构模式下,工作流如下：")]),t._v(" "),a("ul",[a("li",[t._v("每个更新任务都会被赋予一个优先级。")]),t._v(" "),a("li",[t._v("当更新任务抵达调度器时,高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；")]),t._v(" "),a("li",[t._v("此时若有新的更新任务（记为 B）抵达调度器,调度器会检查它的优先级,若发现 B 的优先级高于当前任务 A,那么当前处于 Reconciler 层的 A 任务就会被中断,调度器会将 B 任务推入 Reconciler 层。")]),t._v(" "),a("li",[t._v("当 B 任务完成渲染后,新一轮的调度开始,之前被中断的 A 任务将会被重新推入 Reconciler 层,继续它的渲染之旅,即“可恢复”。")])]),t._v(" "),a("p",[a("strong",[a("code",[t._v("Fiber")]),t._v(' 架构的核心即是"可中断"、"可恢复"、"优先级"')])]),t._v(" "),a("h3",{attrs:{id:"scheduler-调度器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#scheduler-调度器","aria-hidden":"true"}},[t._v("#")]),t._v(" Scheduler 调度器")]),t._v(" "),a("p",[t._v("这个需要上面提到的"),a("code",[t._v("requestIdleCallback")]),t._v(",React 团队实现了功能更完备的 "),a("code",[t._v("requestIdleCallback")]),t._v(" polyfill,这就是 Scheduler。除了在空闲时触发回调的功能外,Scheduler 还提供了多种调度优先级供任务设置。")]),t._v(" "),a("h3",{attrs:{id:"reconciler-协调器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reconciler-协调器","aria-hidden":"true"}},[t._v("#")]),t._v(" Reconciler 协调器")]),t._v(" "),a("p",[t._v("在 React 15 中是递归处理虚拟 DOM 的,React 16 则是变成了可以中断的循环过程,每次循环都会调用"),a("code",[t._v("shouldYield")]),t._v("判断当前是否有剩余时间。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("workLoopConcurrent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Perform work until Scheduler asks us to yield")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldYield")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// workInProgress表示当前工作进度的树。")]),t._v("\n    workInProgress "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("performUnitOfWork")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("React 16 是如何解决中断更新时 DOM 渲染不完全的问题呢？")]),t._v(" "),a("p",[t._v("在 React 16 中,"),a("code",[t._v("Reconciler")]),t._v("与"),a("code",[t._v("Renderer")]),t._v("不再是交替工作。当"),a("code",[t._v("Scheduler")]),t._v("将任务交给"),a("code",[t._v("Reconciler")]),t._v("后,"),a("code",[t._v("Reconciler")]),t._v("会为变化的虚拟 DOM 打上的标记。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Placement "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*             */")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0b0000000000010")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Update "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*                */")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0b0000000000100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" PlacementAndUpdate "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*    */")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0b0000000000110")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Deletion "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*              */")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0b0000000001000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[a("code",[t._v("Placement")]),t._v("表示插入操作")]),t._v(" "),a("li",[a("code",[t._v("PlacementAndUpdate")]),t._v("表示替换操作")]),t._v(" "),a("li",[a("code",[t._v("Update")]),t._v("表示更新操作")]),t._v(" "),a("li",[a("code",[t._v("Deletion")]),t._v("表示删除操作")])]),t._v(" "),a("p",[t._v("整个"),a("code",[t._v("Scheduler")]),t._v("与"),a("code",[t._v("Reconciler")]),t._v("的工作都在内存中进行,所以即使反复中断,用户也不会看见更新不完全的 DOM。只有当所有组件都完成"),a("code",[t._v("Reconciler")]),t._v("的工作,才会统一交给"),a("code",[t._v("Renderer")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"renderer-渲染器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#renderer-渲染器","aria-hidden":"true"}},[t._v("#")]),t._v(" Renderer 渲染器")]),t._v(" "),a("p",[a("code",[t._v("Renderer")]),t._v("根据"),a("code",[t._v("Reconciler")]),t._v("为虚拟 DOM 打的标记,同步执行对应的 DOM 操作。")]),t._v(" "),a("h2",{attrs:{id:"fiber-架构对生命周期的影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiber-架构对生命周期的影响","aria-hidden":"true"}},[t._v("#")]),t._v(" "),a("code",[t._v("Fiber")]),t._v(" 架构对生命周期的影响")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8eb7f64f3f94a9f8038949001284385~tplv-k3u1fbpfcp-watermark.image",alt:""}})]),t._v(" "),a("ol",[a("li",[t._v("render 阶段：纯净且没有副作用,可能会被 React 暂停、终止或重新启动。")]),t._v(" "),a("li",[t._v("pre-commit 阶段：可以读取 DOM。")]),t._v(" "),a("li",[t._v("commit 阶段：可以使用 DOM,运行副作用,安排更新。")])]),t._v(" "),a("p",[t._v("其中 pre-commit 和 commit 从大阶段上来看都属于 commit 阶段。")]),t._v(" "),a("p",[t._v("在 render 阶段,React 主要是在内存中做计算,明确 DOM 树的更新点；而 commit 阶段,则负责把 render 阶段生成的更新真正地执行掉。")]),t._v(" "),a("p",[t._v("新老两种架构对 React 生命周期的影响主要在 render 这个阶段,这个影响是通过增加 Scheduler 层和改写 Reconciler 层来实现的。")]),t._v(" "),a("p",[t._v("在 render 阶段,一个庞大的更新任务被分解为了一个个的工作单元,这些工作单元有着不同的优先级,React 可以根据优先级的高低去实现工作单元的打断和恢复。")]),t._v(" "),a("p",[t._v("之前写过一篇文章关于为什么 React 一些旧生命周期函数打算废弃的原因："),a("a",{attrs:{href:"https://juejin.cn/post/6900703477480685582",target:"_blank",rel:"noopener noreferrer"}},[t._v("谈谈对 React 新旧生命周期的理解"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("而这次从 Firber 机制 render 阶段的角度看这三个生命周期,这三个生命周期的共同特点是都处于 render 阶段：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("componentWillMount\ncomponentWillUpdate\ncomponentWillReceiveProps\n\n")])])]),a("p",[t._v("由于 render 阶段是允许暂停、终止和重启的,这就导致 render 阶段的生命周期都有可能被重复执行,故也是废弃他们的原因之一。")]),t._v(" "),a("h2",{attrs:{id:"fiber-更新过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiber-更新过程","aria-hidden":"true"}},[t._v("#")]),t._v(" "),a("code",[t._v("Fiber")]),t._v(" 更新过程")]),t._v(" "),a("p",[t._v("虚拟 DOM 更新过程分为 2 个阶段：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("render/reconciliation 协调阶段(可中断/异步)")]),t._v("：通过 Diff 算法找出所有节点变更,例如节点新增、删除、属性变更等等, 获得需要更新的节点信息,对应早期版本的 Diff 过程。")]),t._v(" "),a("li",[a("strong",[t._v("commit 提交阶段(不可中断/同步)")]),t._v("：将需要更新的节点一次过批量更新,对应早期版本的 patch 过程。")])]),t._v(" "),a("h3",{attrs:{id:"协调阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协调阶段","aria-hidden":"true"}},[t._v("#")]),t._v(" 协调阶段")]),t._v(" "),a("p",[t._v("在协调阶段会进行 Diff 计算,会生成一棵 "),a("code",[t._v("Fiber")]),t._v(" 树。")]),t._v(" "),a("p",[t._v("该阶段开始于"),a("code",[t._v("performSyncWorkOnRoot")]),t._v("或"),a("code",[t._v("performConcurrentWorkOnRoot")]),t._v("方法的调用。这取决于本次更新是同步更新还是异步更新。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// performSyncWorkOnRoot会调用该方法")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("workLoopSync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("performUnitOfWork")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// performConcurrentWorkOnRoot会调用该方法")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("workLoopConcurrent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldYield")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("performUnitOfWork")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("它们唯一的区别是是否调用"),a("code",[t._v("shouldYield")]),t._v("。如果当前浏览器帧没有剩余时间,"),a("code",[t._v("shouldYield")]),t._v("会中止循环,直到浏览器有空闲时间后再继续遍历。")]),t._v(" "),a("p",[a("code",[t._v("workInProgress")]),t._v("代表当前已创建的 workInProgress fiber。")]),t._v(" "),a("p",[a("code",[t._v("performUnitOfWork")]),t._v("方法将触发对 "),a("code",[t._v("beginWork")]),t._v(" 的调用,进而实现对新 "),a("code",[t._v("Fiber")]),t._v(" 节点的创建。若 "),a("code",[t._v("beginWork")]),t._v(" 所创建的 "),a("code",[t._v("Fiber")]),t._v(" 节点不为空,则 "),a("code",[t._v("performUniOfWork")]),t._v(" 会用这个新的 "),a("code",[t._v("Fiber")]),t._v(" 节点来更新 "),a("code",[t._v("workInProgress")]),t._v(" 的值,为下一次循环做准备。")]),t._v(" "),a("p",[t._v("通过循环调用 "),a("code",[t._v("performUnitOfWork")]),t._v(" 来触发 "),a("code",[t._v("beginWork")]),t._v(",新的 "),a("code",[t._v("Fiber")]),t._v(" 节点就会被不断地创建。当 "),a("code",[t._v("workInProgress")]),t._v(" 终于为空时,说明没有新的节点可以创建了,也就意味着已经完成对整棵 "),a("code",[t._v("Fiber")]),t._v(" 树的构建。")]),t._v(" "),a("p",[t._v("我们知道 "),a("code",[t._v("Fiber")]),t._v(" Reconciler 是从 Stack Reconciler 重构而来,通过遍历的方式实现可中断的递归,所以"),a("code",[t._v("performUnitOfWork")]),t._v('的工作可以分为两部分："递"和"归"。')]),t._v(" "),a("p",[a("strong",[t._v('"递阶段"')])]),t._v(" "),a("p",[t._v("首先从 rootFiber 开始向下深度优先遍历。为遍历到的每个 "),a("code",[t._v("Fiber")]),t._v(" 节点调用"),a("code",[t._v("beginWork")]),t._v("方法。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("beginWork")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  current"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token template-string"}},[a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("Fiber")]),a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前组件对应的Fiber节点在上一次更新时的Fiber节点")]),t._v("\n  workInProgress"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token template-string"}},[a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("Fiber")]),a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 当前组件对应的Fiber节点")]),t._v("\n  renderExpirationTime"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" ExpirationTime "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 优先级相关")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token template-string"}},[a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("Fiber")]),a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...省略函数体")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("该方法会根据传入的 "),a("code",[t._v("Fiber")]),t._v(" 节点创建子 "),a("code",[t._v("Fiber")]),t._v(" 节点,并将这两个 "),a("code",[t._v("Fiber")]),t._v(" 节点连接起来。")]),t._v(" "),a("p",[t._v('当遍历到叶子节点（即没有子组件的组件）时就会进入"归"阶段。')]),t._v(" "),a("p",[a("strong",[t._v('"归阶段"')])]),t._v(" "),a("p",[t._v('在"归"阶段会调用'),a("code",[t._v("completeWork")]),t._v("处理 "),a("code",[t._v("Fiber")]),t._v(" 节点。")]),t._v(" "),a("blockquote",[a("p",[t._v("completeWork 将根据 workInProgress 节点的 tag 属性的不同,进入不同的 DOM 节点的创建、处理逻辑。")])]),t._v(" "),a("p",[t._v("completeWork 内部有 3 个关键动作：")]),t._v(" "),a("ul",[a("li",[t._v("创建 DOM 节点（CreateInstance）")]),t._v(" "),a("li",[t._v("将 DOM 节点插入到 DOM 树中（AppendAllChildren）")]),t._v(" "),a("li",[t._v("为 DOM 节点设置属性（FinalizeInitialChildren）")])]),t._v(" "),a("p",[t._v("当某个 "),a("code",[t._v("Fiber")]),t._v(" 节点执行完"),a("code",[t._v("completeWork")]),t._v(",如果其存在兄弟 "),a("code",[t._v("Fiber")]),t._v(" 节点（即"),a("code",[t._v("fiber.sibling !== null")]),t._v("）,会进入其兄弟 "),a("code",[t._v("Fiber")]),t._v(' 的"递"阶段。')]),t._v(" "),a("p",[t._v("如果不存在兄弟 Fiber,会进入父级 "),a("code",[t._v("Fiber")]),t._v(' 的"归"阶段。')]),t._v(" "),a("p",[t._v('"递"和"归"阶段会交错执行直到"归"到 rootFiber。至此,协调阶段的工作就结束了。')]),t._v(" "),a("h3",{attrs:{id:"commit-提交阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commit-提交阶段","aria-hidden":"true"}},[t._v("#")]),t._v(" commit 提交阶段")]),t._v(" "),a("p",[t._v("commit 阶段的主要工作（即 Renderer 的工作流程）分为三部分：")]),t._v(" "),a("ul",[a("li",[t._v("before mutation 阶段,这个阶段 DOM 节点还没有被渲染到界面上去,过程中会触发 "),a("code",[t._v("getSnapshotBeforeUpdate")]),t._v(",也会处理 "),a("code",[t._v("useEffect")]),t._v(" 钩子相关的调度逻辑。")]),t._v(" "),a("li",[t._v("mutation 阶段,这个阶段负责 DOM 节点的渲染。在渲染过程中,会遍历 effectList,根据 flags（effectTag）的不同,执行不同的 DOM 操作。")]),t._v(" "),a("li",[t._v("layout 阶段,这个阶段处理 DOM 渲染完毕之后的收尾逻辑。比如调用 "),a("code",[t._v("componentDidMount/componentDidUpdate")]),t._v(",调用 "),a("code",[t._v("useLayoutEffect")]),t._v(" 钩子函数的回调等。除了这些之外,它还会把 fiberRoot 的 current 指针指向 workInProgress "),a("code",[t._v("Fiber")]),t._v(" 树。")])]),t._v(" "),a("p",[t._v("参考：")]),t._v(" "),a("ul",[a("li",[t._v("修言-深入浅出搞定 React")]),t._v(" "),a("li",[t._v("React 技术揭秘")])]),t._v(" "),a("p",[t._v("转载自"),a("a",{attrs:{href:"https://juejin.cn/post/6926432527980691470",target:"_blank",rel:"noopener noreferrer"}},[t._v("浅谈对React Fiber的理解"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);